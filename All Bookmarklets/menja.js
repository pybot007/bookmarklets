javascript:document.writeln("<html>"),document.writeln("    <head>"),document.writeln("        <style>"),document.writeln(""),document.writeln("body {"),document.writeln("	margin: 0;"),document.writeln("	background-color: #000;"),document.writeln("	background-image: radial-gradient(ellipse at top, #335476 0.0%, #31506e 11.1%, #304b67 22.2%, #2f4760 33.3%, #2d4359 44.4%, #2c3f51 55.6%, #2a3a4a 66.7%, #293643 77.8%, #28323d 88.9%, #262e36 100.0%);"),document.writeln("	height: 100vh;"),document.writeln("	overflow: hidden;"),document.writeln(""),document.writeln("	font-family: monospace;"),document.writeln("	font-weight: bold;"),document.writeln("	letter-spacing: 0.06em;"),document.writeln("	color: rgba(255, 255, 255, 0.75);"),document.writeln("}"),document.writeln(""),document.writeln("#c {"),document.writeln("	display: block;"),document.writeln("	touch-action: none;"),document.writeln("	transform: translateZ(0);"),document.writeln("}"),document.writeln(""),document.writeln(""),document.writeln("/*/////////////////////"),document.writeln("//        HUD        //"),document.writeln("/////////////////////*/"),document.writeln(""),document.writeln(""),document.writeln(".hud__score,"),document.writeln(".pause-btn {"),document.writeln("	position: fixed;"),document.writeln("	font-size: calc(14px + 2vw + 1vh);"),document.writeln("}"),document.writeln(""),document.writeln(".hud__score {"),document.writeln("	top: 0.65em;"),document.writeln("	left: 0.65em;"),document.writeln("	pointer-events: none;"),document.writeln("	user-select: none;"),document.writeln("}"),document.writeln(""),document.writeln(".cube-count-lbl {"),document.writeln("	font-size: 0.46em;"),document.writeln("}"),document.writeln(""),document.writeln(".pause-btn {"),document.writeln("	position: fixed;"),document.writeln("	top: 0;"),document.writeln("	right: 0;"),document.writeln("	padding: 0.8em 0.65em;"),document.writeln("}"),document.writeln(""),document.writeln(".pause-btn > div {"),document.writeln("	position: relative;"),document.writeln("	width: 0.8em;"),document.writeln("	height: 0.8em;"),document.writeln("	opacity: 0.75;"),document.writeln("}"),document.writeln(""),document.writeln(".pause-btn > div::before,"),document.writeln(".pause-btn > div::after {"),document.writeln("	content: '';"),document.writeln("	display: block;"),document.writeln("	width: 34%;"),document.writeln("	height: 100%;"),document.writeln("	position: absolute;"),document.writeln("	background-color: #fff;"),document.writeln("}"),document.writeln(""),document.writeln(".pause-btn > div::after {"),document.writeln("	right: 0;"),document.writeln("}"),document.writeln(""),document.writeln(".slowmo {"),document.writeln("	position: fixed;"),document.writeln("	bottom: 0;"),document.writeln("	width: 100%;"),document.writeln("	pointer-events: none;"),document.writeln("	opacity: 0;"),document.writeln("	transition: opacity 0.4s;"),document.writeln("	will-change: opacity;"),document.writeln("}"),document.writeln(""),document.writeln(".slowmo::before {"),document.writeln("	content: 'SLOW-MO';"),document.writeln("	display: block;"),document.writeln("	font-size: calc(8px + 1vw + 0.5vh);"),document.writeln("	margin-left: 0.5em;"),document.writeln("	margin-bottom: 8px;"),document.writeln("}"),document.writeln(""),document.writeln(".slowmo::after {"),document.writeln("	content: '';"),document.writeln("	display: block;"),document.writeln("	position: fixed;"),document.writeln("	bottom: 0;"),document.writeln("	width: 100%;"),document.writeln("	height: 1.5vh;"),document.writeln("	background-color: rgba(0, 0, 0, 0.25);"),document.writeln("	z-index: -1;"),document.writeln("}"),document.writeln(""),document.writeln(".slowmo__bar {"),document.writeln("	height: 1.5vh;"),document.writeln("	background-color: rgba(255, 255, 255, 0.75);"),document.writeln("	transform-origin: 0 0;"),document.writeln("}"),document.writeln(""),document.writeln(""),document.writeln(""),document.writeln("/*/////////////////////"),document.writeln("//       MENUS       //"),document.writeln("/////////////////////*/"),document.writeln(""),document.writeln(".menus::before {"),document.writeln("	content: '';"),document.writeln("	pointer-events: none;"),document.writeln("	position: fixed;"),document.writeln("	top: 0;"),document.writeln("	right: 0;"),document.writeln("	bottom: 0;"),document.writeln("	left: 0;"),document.writeln("	background-color: #000;"),document.writeln("	opacity: 0;"),document.writeln("	transition: opacity 0.2s;"),document.writeln("	transition-timing-function: ease-in;"),document.writeln("}"),document.writeln(""),document.writeln(".menus.has-active::before {"),document.writeln("	opacity: 0.08;"),document.writeln("	transition-duration: 0.4s;"),document.writeln("	transition-timing-function: ease-out;"),document.writeln("}"),document.writeln(""),document.writeln(".menus.interactive-mode::before {"),document.writeln("	opacity: 0.02;"),document.writeln("}"),document.writeln(""),document.writeln(""),document.writeln(""),document.writeln("/* Menu containers */"),document.writeln(".menu {"),document.writeln("	pointer-events: none;"),document.writeln("	position: fixed;"),document.writeln("	top: 0;"),document.writeln("	right: 0;"),document.writeln("	bottom: 0;"),document.writeln("	left: 0;"),document.writeln("	display: flex;"),document.writeln("	flex-direction: column;"),document.writeln("	justify-content: center;"),document.writeln("	align-items: center;"),document.writeln("	user-select: none;"),document.writeln("	text-align: center;"),document.writeln("	color: rgba(255, 255, 255, 0.9);"),document.writeln("	opacity: 0;"),document.writeln("	visibility: hidden;"),document.writeln("	transform: translateY(30px);"),document.writeln("	transition-property: opacity, visibility, transform;"),document.writeln("	transition-duration: 0.2s;"),document.writeln("	transition-timing-function: ease-in;"),document.writeln("}"),document.writeln(""),document.writeln(".menu.active {"),document.writeln("	opacity: 1;"),document.writeln("	visibility: visible;"),document.writeln("	transform: translateY(0);"),document.writeln("	transition-duration: 0.4s;"),document.writeln("	transition-timing-function: ease-out;"),document.writeln("}"),document.writeln(""),document.writeln(".menus.interactive-mode .menu.active {"),document.writeln("	opacity: 0.6;"),document.writeln("}"),document.writeln(""),document.writeln(".menus:not(.interactive-mode) .menu.active > * {"),document.writeln("	pointer-events: auto;"),document.writeln("}"),document.writeln(""),document.writeln(""),document.writeln("/* Common menu elements */"),document.writeln(""),document.writeln("h1 {"),document.writeln("	font-size: 4rem;"),document.writeln("	line-height: 0.95;"),document.writeln("	text-align: center;"),document.writeln("	font-weight: bold;"),document.writeln("	margin: 0 0.65em 1em;"),document.writeln("}"),document.writeln(""),document.writeln("h2 {"),document.writeln("	font-size: 1.2rem;"),document.writeln("	line-height: 1;"),document.writeln("	text-align: center;"),document.writeln("	font-weight: bold;"),document.writeln("	margin: -1em 0.65em 1em;"),document.writeln("}"),document.writeln(""),document.writeln(".final-score-lbl {"),document.writeln("	font-size: 5rem;"),document.writeln("	margin: -0.2em 0 0;"),document.writeln("}"),document.writeln(""),document.writeln(".high-score-lbl {"),document.writeln("	font-size: 1.2rem;"),document.writeln("	margin: 0 0 2.5em;"),document.writeln("}"),document.writeln(""),document.writeln("button {"),document.writeln("	display: block;"),document.writeln("	position: relative;"),document.writeln("	width: 200px;"),document.writeln("	padding: 12px 20px;"),document.writeln("	background: transparent;"),document.writeln("	border: none;"),document.writeln("	outline: none;"),document.writeln("	user-select: none;"),document.writeln("	font-family: monospace;"),document.writeln("	font-weight: bold;"),document.writeln("	font-size: 1.4rem;"),document.writeln("	color: #fff;"),document.writeln("	opacity: 0.75;"),document.writeln("	transition: opacity 0.3s;"),document.writeln("}"),document.writeln(""),document.writeln("button::before {"),document.writeln("	content: '';"),document.writeln("	position: absolute;"),document.writeln("	top: 0;"),document.writeln("	right: 0;"),document.writeln("	bottom: 0;"),document.writeln("	left: 0;"),document.writeln("	background-color: rgba(255, 255, 255, 0.15);"),document.writeln("	transform: scale(0, 0);"),document.writeln("	opacity: 0;"),document.writeln("	transition: opacity 0.3s, transform 0.3s;"),document.writeln("}"),document.writeln(""),document.writeln("/* No `:focus` styles because this is a mouse/touch game! */"),document.writeln("button:active {"),document.writeln("	opacity: 1;"),document.writeln("}"),document.writeln(""),document.writeln("button:active::before {"),document.writeln("	transform: scale(1, 1);"),document.writeln("	opacity: 1;"),document.writeln("}"),document.writeln(""),document.writeln(".credits {"),document.writeln("	position: fixed;"),document.writeln("	width: 100%;"),document.writeln("	left: 0;"),document.writeln("	bottom: 20px;"),document.writeln("}"),document.writeln(""),document.writeln("a {"),document.writeln("	color: white;"),document.writeln("}"),document.writeln(""),document.writeln("/* Only enable hover state on large screens */"),document.writeln("@media (min-width: 1025px) {"),document.writeln("	button:hover {"),document.writeln("		opacity: 1;"),document.writeln("	}"),document.writeln(""),document.writeln("	button:hover::before {"),document.writeln("		transform: scale(1, 1);"),document.writeln("		opacity: 1;"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("        </style>"),document.writeln("    </head>"),document.writeln(""),document.writeln(""),document.writeln("    <body>"),document.writeln("        <!-- Game canvas -->"),document.writeln('<canvas id="c"></canvas>'),document.writeln(""),document.writeln("<!-- Gameplay HUD -->"),document.writeln('<div class="hud">'),document.writeln('	<div class="hud__score">'),document.writeln('		<div class="score-lbl"></div>'),document.writeln('		<div class="cube-count-lbl"></div>'),document.writeln("	</div>"),document.writeln('	<div class="pause-btn"><div></div></div>'),document.writeln('	<div class="slowmo">'),document.writeln('		<div class="slowmo__bar"></div>'),document.writeln("	</div>"),document.writeln("</div>"),document.writeln(""),document.writeln("<!-- Menu System -->"),document.writeln('<div class="menus">'),document.writeln('	<div class="menu menu--main">'),document.writeln("		<h1>MENJA</h1>"),document.writeln('		<button type="button" class="play-normal-btn">PLAY GAME</button>'),document.writeln('		<button type="button" class="play-casual-btn">CASUAL MODE</button>'),document.writeln('		<div class="credits">An 8kB game by <a href="https://cmiller.tech">Caleb Miller</a></div>'),document.writeln("	</div>"),document.writeln('	<div class="menu menu--pause">'),document.writeln("		<h1>Paused</h1>"),document.writeln('		<button type="button" class="resume-btn">RESUME GAME</button>'),document.writeln('		<button type="button" class="menu-btn--pause">MAIN MENU</button>'),document.writeln("	</div>"),document.writeln('	<div class="menu menu--score">'),document.writeln("		<h1>Game Over</h1>"),document.writeln("		<h2>Your Score:</h2>"),document.writeln('		<div class="final-score-lbl"></div>'),document.writeln('		<div class="high-score-lbl"></div>'),document.writeln('		<button type="button" class="play-again-btn">PLAY AGAIN</button>'),document.writeln('		<button type="button" class="menu-btn--score">MAIN MENU</button>'),document.writeln("	</div>"),document.writeln("</div>"),document.writeln("    <script>"),document.writeln("        // globalConfig.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("// Provides global variables used by the entire program."),document.writeln("// Most of this should be configuration."),document.writeln(""),document.writeln("// Timing multiplier for entire game engine."),document.writeln("let gameSpeed = 1;"),document.writeln(""),document.writeln("// Colors"),document.writeln("const BLUE = { r: 0x67, g: 0xd7, b: 0xf0 };"),document.writeln("const GREEN = { r: 0xa6, g: 0xe0, b: 0x2c };"),document.writeln("const PINK = { r: 0xfa, g: 0x24, b: 0x73 };"),document.writeln("const ORANGE = { r: 0xfe, g: 0x95, b: 0x22 };"),document.writeln("const allColors = [BLUE, GREEN, PINK, ORANGE];"),document.writeln(""),document.writeln("// Gameplay"),document.writeln("const getSpawnDelay = () => {"),document.writeln("	const spawnDelayMax = 1400;"),document.writeln("	const spawnDelayMin = 550;"),document.writeln("	const spawnDelay = spawnDelayMax - state.game.cubeCount * 3.1;"),document.writeln("	return Math.max(spawnDelay, spawnDelayMin);"),document.writeln("};"),document.writeln("const doubleStrongEnableScore = 2000;"),document.writeln("// Number of cubes that must be smashed before activating a feature."),document.writeln("const slowmoThreshold = 10;"),document.writeln("const strongThreshold = 25;"),document.writeln("const spinnerThreshold = 25;"),document.writeln(""),document.writeln("// Interaction state"),document.writeln("let pointerIsDown = false;"),document.writeln("// The last known position of the primary pointer in screen coordinates.`"),document.writeln("let pointerScreen = { x: 0, y: 0 };"),document.writeln("// Same as `pointerScreen`, but converted to scene coordinates in rAF."),document.writeln("let pointerScene = { x: 0, y: 0 };"),document.writeln('// Minimum speed of pointer before "hits" are counted.'),document.writeln("const minPointerSpeed = 60;"),document.writeln("// The hit speed affects the direction the target post-hit. This number dampens that force."),document.writeln("const hitDampening = 0.1;"),document.writeln("// Backboard receives shadows and is the farthest negative Z position of entities."),document.writeln("const backboardZ = -400;"),document.writeln('const shadowColor = "#262e36";'),document.writeln("// How much air drag is applied to standard objects"),document.writeln("const airDrag = 0.022;"),document.writeln("const gravity = 0.3;"),document.writeln("// Spark config"),document.writeln('const sparkColor = "rgba(170,221,255,.9)";'),document.writeln("const sparkThickness = 2.2;"),document.writeln("const airDragSpark = 0.1;"),document.writeln("// Track pointer positions to show trail"),document.writeln('const touchTrailColor = "rgba(170,221,255,.62)";'),document.writeln("const touchTrailThickness = 7;"),document.writeln("const touchPointLife = 120;"),document.writeln("const touchPoints = [];"),document.writeln("// Size of in-game targets. This affects rendered size and hit area."),document.writeln("const targetRadius = 40;"),document.writeln("const targetHitRadius = 50;"),document.writeln("const makeTargetGlueColor = (target) => {"),document.writeln("	// const alpha = (target.health - 1) / (target.maxHealth - 1);"),document.writeln("	// return `rgba(170,221,255,${alpha.toFixed(3)})`;"),document.writeln('	return "rgb(170,221,255)";'),document.writeln("};"),document.writeln("// Size of target fragments"),document.writeln("const fragRadius = targetRadius / 3;"),document.writeln(""),document.writeln("// Game canvas element needed in setup.js and interaction.js"),document.writeln('const canvas = document.querySelector("#c");'),document.writeln(""),document.writeln("// 3D camera config"),document.writeln("// Affects perspective"),document.writeln("const cameraDistance = 900;"),document.writeln("// Does not affect perspective"),document.writeln("const sceneScale = 1;"),document.writeln("// Objects that get too close to the camera will be faded out to transparent over this range."),document.writeln("// const cameraFadeStartZ = 0.8*cameraDistance - 6*targetRadius;"),document.writeln("const cameraFadeStartZ = 0.45 * cameraDistance;"),document.writeln("const cameraFadeEndZ = 0.65 * cameraDistance;"),document.writeln("const cameraFadeRange = cameraFadeEndZ - cameraFadeStartZ;"),document.writeln(""),document.writeln("// Globals used to accumlate all vertices/polygons in each frame"),document.writeln("const allVertices = [];"),document.writeln("const allPolys = [];"),document.writeln("const allShadowVertices = [];"),document.writeln("const allShadowPolys = [];"),document.writeln(""),document.writeln("// state.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("///////////"),document.writeln("// Enums //"),document.writeln("///////////"),document.writeln(""),document.writeln("// Game Modes"),document.writeln('const GAME_MODE_RANKED = Symbol("GAME_MODE_RANKED");'),document.writeln('const GAME_MODE_CASUAL = Symbol("GAME_MODE_CASUAL");'),document.writeln(""),document.writeln("// Available Menus"),document.writeln('const MENU_MAIN = Symbol("MENU_MAIN");'),document.writeln('const MENU_PAUSE = Symbol("MENU_PAUSE");'),document.writeln('const MENU_SCORE = Symbol("MENU_SCORE");'),document.writeln(""),document.writeln("//////////////////"),document.writeln("// Global State //"),document.writeln("//////////////////"),document.writeln(""),document.writeln("const state = {"),document.writeln("	game: {"),document.writeln("		mode: GAME_MODE_RANKED,"),document.writeln("		// Run time of current game."),document.writeln("		time: 0,"),document.writeln("		// Player score."),document.writeln("		score: 0,"),document.writeln("		// Total number of cubes smashed in game."),document.writeln("		cubeCount: 0"),document.writeln("	},"),document.writeln("	menus: {"),document.writeln("		// Set to `null` to hide all menus"),document.writeln("		active: MENU_MAIN"),document.writeln("	}"),document.writeln("};"),document.writeln(""),document.writeln("////////////////////////////"),document.writeln("// Global State Selectors //"),document.writeln("////////////////////////////"),document.writeln(""),document.writeln("const isInGame = () => !state.menus.active;"),document.writeln("const isMenuVisible = () => !!state.menus.active;"),document.writeln("const isCasualGame = () => state.game.mode === GAME_MODE_CASUAL;"),document.writeln("const isPaused = () => state.menus.active === MENU_PAUSE;"),document.writeln(""),document.writeln("///////////////////"),document.writeln("// Local Storage //"),document.writeln("///////////////////"),document.writeln(""),document.writeln('const highScoreKey = "__menja__highScore";'),document.writeln("const getHighScore = () => {"),document.writeln("	const raw = localStorage.getItem(highScoreKey);"),document.writeln("	return raw ? parseInt(raw, 10) : 0;"),document.writeln("};"),document.writeln(""),document.writeln("let _lastHighscore = getHighScore();"),document.writeln("const setHighScore = (score) => {"),document.writeln("	_lastHighscore = getHighScore();"),document.writeln("	localStorage.setItem(highScoreKey, String(score));"),document.writeln("};"),document.writeln(""),document.writeln("const isNewHighScore = () => state.game.score > _lastHighscore;"),document.writeln(""),document.writeln("// utils.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("const invariant = (condition, message) => {"),document.writeln("	if (!condition) throw new Error(message);"),document.writeln("};"),document.writeln(""),document.writeln("/////////"),document.writeln("// DOM //"),document.writeln("/////////"),document.writeln(""),document.writeln("const $ = (selector) => document.querySelector(selector);"),document.writeln("const handleClick = (element, handler) =>"),document.writeln('	element.addEventListener("click", handler);'),document.writeln("const handlePointerDown = (element, handler) => {"),document.writeln('	element.addEventListener("touchstart", handler);'),document.writeln('	element.addEventListener("mousedown", handler);'),document.writeln("};"),document.writeln(""),document.writeln("////////////////////////"),document.writeln("// Formatting Helpers //"),document.writeln("////////////////////////"),document.writeln(""),document.writeln("// Converts a number into a formatted string with thousand separators."),document.writeln("const formatNumber = (num) => num.toLocaleString();"),document.writeln(""),document.writeln("////////////////////"),document.writeln("// Math Constants //"),document.writeln("////////////////////"),document.writeln(""),document.writeln("const PI = Math.PI;"),document.writeln("const TAU = Math.PI * 2;"),document.writeln("const ETA = Math.PI * 0.5;"),document.writeln(""),document.writeln("//////////////////"),document.writeln("// Math Helpers //"),document.writeln("//////////////////"),document.writeln(""),document.writeln("// Clamps a number between min and max values (inclusive)"),document.writeln("const clamp = (num, min, max) => Math.min(Math.max(num, min), max);"),document.writeln(""),document.writeln("// Linearly interpolate between numbers a and b by a specific amount."),document.writeln("// mix >= 0 && mix <= 1"),document.writeln("const lerp = (a, b, mix) => (b - a) * mix + a;"),document.writeln(""),document.writeln("////////////////////"),document.writeln("// Random Helpers //"),document.writeln("////////////////////"),document.writeln(""),document.writeln("// Generates a random number between min (inclusive) and max (exclusive)"),document.writeln("const random = (min, max) => Math.random() * (max - min) + min;"),document.writeln(""),document.writeln("// Generates a random integer between and possibly including min and max values"),document.writeln("const randomInt = (min, max) => ((Math.random() * (max - min + 1)) | 0) + min;"),document.writeln(""),document.writeln("// Returns a random element from an array"),document.writeln("const pickOne = (arr) => arr[(Math.random() * arr.length) | 0];"),document.writeln(""),document.writeln("///////////////////"),document.writeln("// Color Helpers //"),document.writeln("///////////////////"),document.writeln(""),document.writeln("// Converts an { r, g, b } color object to a 6-digit hex code."),document.writeln("const colorToHex = (color) => {"),document.writeln("	return ("),document.writeln('		"#" +'),document.writeln('		(color.r | 0).toString(16).padStart(2, "0") +'),document.writeln('		(color.g | 0).toString(16).padStart(2, "0") +'),document.writeln('		(color.b | 0).toString(16).padStart(2, "0")'),document.writeln("	);"),document.writeln("};"),document.writeln(""),document.writeln("// Operates on an { r, g, b } color object."),document.writeln("// Returns string hex code."),document.writeln("// `lightness` must range from 0 to 1. 0 is pure black, 1 is pure white."),document.writeln("const shadeColor = (color, lightness) => {"),document.writeln("	let other, mix;"),document.writeln("	if (lightness < 0.5) {"),document.writeln("		other = 0;"),document.writeln("		mix = 1 - lightness * 2;"),document.writeln("	} else {"),document.writeln("		other = 255;"),document.writeln("		mix = lightness * 2 - 1;"),document.writeln("	}"),document.writeln("	return ("),document.writeln('		"#" +'),document.writeln('		(lerp(color.r, other, mix) | 0).toString(16).padStart(2, "0") +'),document.writeln('		(lerp(color.g, other, mix) | 0).toString(16).padStart(2, "0") +'),document.writeln('		(lerp(color.b, other, mix) | 0).toString(16).padStart(2, "0")'),document.writeln("	);"),document.writeln("};"),document.writeln(""),document.writeln("////////////////////"),document.writeln("// Timing Helpers //"),document.writeln("////////////////////"),document.writeln(""),document.writeln("const _allCooldowns = [];"),document.writeln(""),document.writeln("const makeCooldown = (rechargeTime, units = 1) => {"),document.writeln("	let timeRemaining = 0;"),document.writeln("	let lastTime = 0;"),document.writeln(""),document.writeln("	const initialOptions = { rechargeTime, units };"),document.writeln(""),document.writeln("	const updateTime = () => {"),document.writeln("		const now = state.game.time;"),document.writeln("		// Reset time remaining if time goes backwards."),document.writeln("		if (now < lastTime) {"),document.writeln("			timeRemaining = 0;"),document.writeln("		} else {"),document.writeln("			// update..."),document.writeln("			timeRemaining -= now - lastTime;"),document.writeln("			if (timeRemaining < 0) timeRemaining = 0;"),document.writeln("		}"),document.writeln("		lastTime = now;"),document.writeln("	};"),document.writeln(""),document.writeln("	const canUse = () => {"),document.writeln("		updateTime();"),document.writeln("		return timeRemaining <= rechargeTime * (units - 1);"),document.writeln("	};"),document.writeln(""),document.writeln("	const cooldown = {"),document.writeln("		canUse,"),document.writeln("		useIfAble() {"),document.writeln("			const usable = canUse();"),document.writeln("			if (usable) timeRemaining += rechargeTime;"),document.writeln("			return usable;"),document.writeln("		},"),document.writeln("		mutate(options) {"),document.writeln("			if (options.rechargeTime) {"),document.writeln("				// Apply recharge time delta so change takes effect immediately."),document.writeln("				timeRemaining -= rechargeTime - options.rechargeTime;"),document.writeln("				if (timeRemaining < 0) timeRemaining = 0;"),document.writeln("				rechargeTime = options.rechargeTime;"),document.writeln("			}"),document.writeln("			if (options.units) units = options.units;"),document.writeln("		},"),document.writeln("		reset() {"),document.writeln("			timeRemaining = 0;"),document.writeln("			lastTime = 0;"),document.writeln("			this.mutate(initialOptions);"),document.writeln("		}"),document.writeln("	};"),document.writeln(""),document.writeln("	_allCooldowns.push(cooldown);"),document.writeln(""),document.writeln("	return cooldown;"),document.writeln("};"),document.writeln(""),document.writeln("const resetAllCooldowns = () =>"),document.writeln("	_allCooldowns.forEach((cooldown) => cooldown.reset());"),document.writeln(""),document.writeln("const makeSpawner = ({ chance, cooldownPerSpawn, maxSpawns }) => {"),document.writeln("	const cooldown = makeCooldown(cooldownPerSpawn, maxSpawns);"),document.writeln("	return {"),document.writeln("		shouldSpawn() {"),document.writeln("			return Math.random() <= chance && cooldown.useIfAble();"),document.writeln("		},"),document.writeln("		mutate(options) {"),document.writeln("			if (options.chance) chance = options.chance;"),document.writeln("			cooldown.mutate({"),document.writeln("				rechargeTime: options.cooldownPerSpawn,"),document.writeln("				units: options.maxSpawns"),document.writeln("			});"),document.writeln("		}"),document.writeln("	};"),document.writeln("};"),document.writeln(""),document.writeln("////////////////////"),document.writeln("// Vector Helpers //"),document.writeln("////////////////////"),document.writeln(""),document.writeln("const normalize = (v) => {"),document.writeln("	const mag = Math.hypot(v.x, v.y, v.z);"),document.writeln("	return {"),document.writeln("		x: v.x / mag,"),document.writeln("		y: v.y / mag,"),document.writeln("		z: v.z / mag"),document.writeln("	};"),document.writeln("};"),document.writeln(""),document.writeln("// Curried math helpers"),document.writeln("const add = (a) => (b) => a + b;"),document.writeln("// Curried vector helpers"),document.writeln("const scaleVector = (scale) => (vector) => {"),document.writeln("	vector.x *= scale;"),document.writeln("	vector.y *= scale;"),document.writeln("	vector.z *= scale;"),document.writeln("};"),document.writeln(""),document.writeln("////////////////"),document.writeln("// 3D Helpers //"),document.writeln("////////////////"),document.writeln(""),document.writeln("// Clone array and all vertices."),document.writeln("function cloneVertices(vertices) {"),document.writeln("	return vertices.map((v) => ({ x: v.x, y: v.y, z: v.z }));"),document.writeln("}"),document.writeln(""),document.writeln("// Copy vertex data from one array into another."),document.writeln("// Arrays must be the same length."),document.writeln("function copyVerticesTo(arr1, arr2) {"),document.writeln("	const len = arr1.length;"),document.writeln("	for (let i = 0; i < len; i++) {"),document.writeln("		const v1 = arr1[i];"),document.writeln("		const v2 = arr2[i];"),document.writeln("		v2.x = v1.x;"),document.writeln("		v2.y = v1.y;"),document.writeln("		v2.z = v1.z;"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("// Compute triangle midpoint."),document.writeln("// Mutates `middle` property of given `poly`."),document.writeln("function computeTriMiddle(poly) {"),document.writeln("	const v = poly.vertices;"),document.writeln("	poly.middle.x = (v[0].x + v[1].x + v[2].x) / 3;"),document.writeln("	poly.middle.y = (v[0].y + v[1].y + v[2].y) / 3;"),document.writeln("	poly.middle.z = (v[0].z + v[1].z + v[2].z) / 3;"),document.writeln("}"),document.writeln(""),document.writeln("// Compute quad midpoint."),document.writeln("// Mutates `middle` property of given `poly`."),document.writeln("function computeQuadMiddle(poly) {"),document.writeln("	const v = poly.vertices;"),document.writeln("	poly.middle.x = (v[0].x + v[1].x + v[2].x + v[3].x) / 4;"),document.writeln("	poly.middle.y = (v[0].y + v[1].y + v[2].y + v[3].y) / 4;"),document.writeln("	poly.middle.z = (v[0].z + v[1].z + v[2].z + v[3].z) / 4;"),document.writeln("}"),document.writeln(""),document.writeln("function computePolyMiddle(poly) {"),document.writeln("	if (poly.vertices.length === 3) {"),document.writeln("		computeTriMiddle(poly);"),document.writeln("	} else {"),document.writeln("		computeQuadMiddle(poly);"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("// Compute distance from any polygon (tri or quad) midpoint to camera."),document.writeln("// Sets `depth` property of given `poly`."),document.writeln("// Also triggers midpoint calculation, which mutates `middle` property of `poly`."),document.writeln("function computePolyDepth(poly) {"),document.writeln("	computePolyMiddle(poly);"),document.writeln("	const dX = poly.middle.x;"),document.writeln("	const dY = poly.middle.y;"),document.writeln("	const dZ = poly.middle.z - cameraDistance;"),document.writeln("	poly.depth = Math.hypot(dX, dY, dZ);"),document.writeln("}"),document.writeln(""),document.writeln("// Compute normal of any polygon. Uses normalized vector cross product."),document.writeln("// Mutates `normalName` property of given `poly`."),document.writeln("function computePolyNormal(poly, normalName) {"),document.writeln("	// Store quick refs to vertices"),document.writeln("	const v1 = poly.vertices[0];"),document.writeln("	const v2 = poly.vertices[1];"),document.writeln("	const v3 = poly.vertices[2];"),document.writeln("	// Calculate difference of vertices, following winding order."),document.writeln("	const ax = v1.x - v2.x;"),document.writeln("	const ay = v1.y - v2.y;"),document.writeln("	const az = v1.z - v2.z;"),document.writeln("	const bx = v1.x - v3.x;"),document.writeln("	const by = v1.y - v3.y;"),document.writeln("	const bz = v1.z - v3.z;"),document.writeln("	// Cross product"),document.writeln("	const nx = ay * bz - az * by;"),document.writeln("	const ny = az * bx - ax * bz;"),document.writeln("	const nz = ax * by - ay * bx;"),document.writeln("	// Compute magnitude of normal and normalize"),document.writeln("	const mag = Math.hypot(nx, ny, nz);"),document.writeln("	const polyNormal = poly[normalName];"),document.writeln("	polyNormal.x = nx / mag;"),document.writeln("	polyNormal.y = ny / mag;"),document.writeln("	polyNormal.z = nz / mag;"),document.writeln("}"),document.writeln(""),document.writeln("// Apply translation/rotation/scale to all given vertices."),document.writeln("// If `vertices` and `target` are the same array, the vertices will be mutated in place."),document.writeln("// If `vertices` and `target` are different arrays, `vertices` will not be touched, instead the"),document.writeln("// transformed values from `vertices` will be written to `target` array."),document.writeln("function transformVertices("),document.writeln("	vertices,"),document.writeln("	target,"),document.writeln("	tX,"),document.writeln("	tY,"),document.writeln("	tZ,"),document.writeln("	rX,"),document.writeln("	rY,"),document.writeln("	rZ,"),document.writeln("	sX,"),document.writeln("	sY,"),document.writeln("	sZ"),document.writeln(") {"),document.writeln("	// Matrix multiplcation constants only need calculated once for all vertices."),document.writeln("	const sinX = Math.sin(rX);"),document.writeln("	const cosX = Math.cos(rX);"),document.writeln("	const sinY = Math.sin(rY);"),document.writeln("	const cosY = Math.cos(rY);"),document.writeln("	const sinZ = Math.sin(rZ);"),document.writeln("	const cosZ = Math.cos(rZ);"),document.writeln(""),document.writeln("	// Using forEach() like map(), but with a (recycled) target array."),document.writeln("	vertices.forEach((v, i) => {"),document.writeln("		const targetVertex = target[i];"),document.writeln("		// X axis rotation"),document.writeln("		const x1 = v.x;"),document.writeln("		const y1 = v.z * sinX + v.y * cosX;"),document.writeln("		const z1 = v.z * cosX - v.y * sinX;"),document.writeln("		// Y axis rotation"),document.writeln("		const x2 = x1 * cosY - z1 * sinY;"),document.writeln("		const y2 = y1;"),document.writeln("		const z2 = x1 * sinY + z1 * cosY;"),document.writeln("		// Z axis rotation"),document.writeln("		const x3 = x2 * cosZ - y2 * sinZ;"),document.writeln("		const y3 = x2 * sinZ + y2 * cosZ;"),document.writeln("		const z3 = z2;"),document.writeln(""),document.writeln("		// Scale, Translate, and set the transform."),document.writeln("		targetVertex.x = x3 * sX + tX;"),document.writeln("		targetVertex.y = y3 * sY + tY;"),document.writeln("		targetVertex.z = z3 * sZ + tZ;"),document.writeln("	});"),document.writeln("}"),document.writeln(""),document.writeln("// 3D projection on a single vertex."),document.writeln("// Directly mutates the vertex."),document.writeln("const projectVertex = (v) => {"),document.writeln("	const focalLength = cameraDistance * sceneScale;"),document.writeln("	const depth = focalLength / (cameraDistance - v.z);"),document.writeln("	v.x = v.x * depth;"),document.writeln("	v.y = v.y * depth;"),document.writeln("};"),document.writeln(""),document.writeln("// 3D projection on a single vertex."),document.writeln("// Mutates a secondary target vertex."),document.writeln("const projectVertexTo = (v, target) => {"),document.writeln("	const focalLength = cameraDistance * sceneScale;"),document.writeln("	const depth = focalLength / (cameraDistance - v.z);"),document.writeln("	target.x = v.x * depth;"),document.writeln("	target.y = v.y * depth;"),document.writeln("};"),document.writeln(""),document.writeln("// PERF.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("// Dummy no-op functions."),document.writeln("// I use these in a special build for custom performance profiling."),document.writeln("const PERF_START = () => {};"),document.writeln("const PERF_END = () => {};"),document.writeln("const PERF_UPDATE = () => {};"),document.writeln(""),document.writeln("// 3dModels.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("// Define models once. The origin is the center of the model."),document.writeln(""),document.writeln("// A simple cube, 8 vertices, 6 quads."),document.writeln("// Defaults to an edge length of 2 units, can be influenced with `scale`."),document.writeln("function makeCubeModel({ scale = 1 }) {"),document.writeln("	return {"),document.writeln("		vertices: ["),document.writeln("			// top"),document.writeln("			{ x: -scale, y: -scale, z: scale },"),document.writeln("			{ x: scale, y: -scale, z: scale },"),document.writeln("			{ x: scale, y: scale, z: scale },"),document.writeln("			{ x: -scale, y: scale, z: scale },"),document.writeln("			// bottom"),document.writeln("			{ x: -scale, y: -scale, z: -scale },"),document.writeln("			{ x: scale, y: -scale, z: -scale },"),document.writeln("			{ x: scale, y: scale, z: -scale },"),document.writeln("			{ x: -scale, y: scale, z: -scale }"),document.writeln("		],"),document.writeln("		polys: ["),document.writeln("			// z = 1"),document.writeln("			{ vIndexes: [0, 1, 2, 3] },"),document.writeln("			// z = -1"),document.writeln("			{ vIndexes: [7, 6, 5, 4] },"),document.writeln("			// y = 1"),document.writeln("			{ vIndexes: [3, 2, 6, 7] },"),document.writeln("			// y = -1"),document.writeln("			{ vIndexes: [4, 5, 1, 0] },"),document.writeln("			// x = 1"),document.writeln("			{ vIndexes: [5, 6, 2, 1] },"),document.writeln("			// x = -1"),document.writeln("			{ vIndexes: [0, 3, 7, 4] }"),document.writeln("		]"),document.writeln("	};"),document.writeln("}"),document.writeln(""),document.writeln("// Not very optimized - lots of duplicate vertices are generated."),document.writeln("function makeRecursiveCubeModel({ recursionLevel, splitFn, color, scale = 1 }) {"),document.writeln("	const getScaleAtLevel = (level) => 1 / 3 ** level;"),document.writeln(""),document.writeln("	// We can model level 0 manually. It's just a single, centered, cube."),document.writeln("	let cubeOrigins = [{ x: 0, y: 0, z: 0 }];"),document.writeln(""),document.writeln("	// Recursively replace cubes with smaller cubes."),document.writeln("	for (let i = 1; i <= recursionLevel; i++) {"),document.writeln("		const scale = getScaleAtLevel(i) * 2;"),document.writeln("		const cubeOrigins2 = [];"),document.writeln("		cubeOrigins.forEach((origin) => {"),document.writeln("			cubeOrigins2.push(...splitFn(origin, scale));"),document.writeln("		});"),document.writeln("		cubeOrigins = cubeOrigins2;"),document.writeln("	}"),document.writeln(""),document.writeln("	const finalModel = { vertices: [], polys: [] };"),document.writeln(""),document.writeln("	// Generate single cube model and scale it."),document.writeln("	const cubeModel = makeCubeModel({ scale: 1 });"),document.writeln("	cubeModel.vertices.forEach(scaleVector(getScaleAtLevel(recursionLevel)));"),document.writeln(""),document.writeln("	// Compute the max distance x, y, or z origin values will be."),document.writeln("	// Same result as `Math.max(...cubeOrigins.map(o => o.x))`, but much faster."),document.writeln("	const maxComponent ="),document.writeln("		getScaleAtLevel(recursionLevel) * (3 ** recursionLevel - 1);"),document.writeln(""),document.writeln("	// Place cube geometry at each origin."),document.writeln("	cubeOrigins.forEach((origin, cubeIndex) => {"),document.writeln("		// To compute occlusion (shading), find origin component with greatest"),document.writeln("		// magnitude and normalize it relative to `maxComponent`."),document.writeln("		const occlusion ="),document.writeln("			Math.max(Math.abs(origin.x), Math.abs(origin.y), Math.abs(origin.z)) /"),document.writeln("			maxComponent;"),document.writeln("		// At lower iterations, occlusion looks better lightened up a bit."),document.writeln("		const occlusionLighter ="),document.writeln("			recursionLevel > 2 ? occlusion : (occlusion + 0.8) / 1.8;"),document.writeln("		// Clone, translate vertices to origin, and apply scale"),document.writeln("		finalModel.vertices.push("),document.writeln("			...cubeModel.vertices.map((v) => ({"),document.writeln("				x: (v.x + origin.x) * scale,"),document.writeln("				y: (v.y + origin.y) * scale,"),document.writeln("				z: (v.z + origin.z) * scale"),document.writeln("			}))"),document.writeln("		);"),document.writeln("		// Clone polys, shift referenced vertex indexes, and compute color."),document.writeln("		finalModel.polys.push("),document.writeln("			...cubeModel.polys.map((poly) => ({"),document.writeln("				vIndexes: poly.vIndexes.map(add(cubeIndex * 8))"),document.writeln("			}))"),document.writeln("		);"),document.writeln("	});"),document.writeln(""),document.writeln("	return finalModel;"),document.writeln("}"),document.writeln(""),document.writeln("// o: Vector3D - Position of cube's origin (center)."),document.writeln("// s: Vector3D - Determines size of menger sponge."),document.writeln("function mengerSpongeSplit(o, s) {"),document.writeln("	return ["),document.writeln("		// Top"),document.writeln("		{ x: o.x + s, y: o.y - s, z: o.z + s },"),document.writeln("		{ x: o.x + s, y: o.y - s, z: o.z + 0 },"),document.writeln("		{ x: o.x + s, y: o.y - s, z: o.z - s },"),document.writeln("		{ x: o.x + 0, y: o.y - s, z: o.z + s },"),document.writeln("		{ x: o.x + 0, y: o.y - s, z: o.z - s },"),document.writeln("		{ x: o.x - s, y: o.y - s, z: o.z + s },"),document.writeln("		{ x: o.x - s, y: o.y - s, z: o.z + 0 },"),document.writeln("		{ x: o.x - s, y: o.y - s, z: o.z - s },"),document.writeln("		// Bottom"),document.writeln("		{ x: o.x + s, y: o.y + s, z: o.z + s },"),document.writeln("		{ x: o.x + s, y: o.y + s, z: o.z + 0 },"),document.writeln("		{ x: o.x + s, y: o.y + s, z: o.z - s },"),document.writeln("		{ x: o.x + 0, y: o.y + s, z: o.z + s },"),document.writeln("		{ x: o.x + 0, y: o.y + s, z: o.z - s },"),document.writeln("		{ x: o.x - s, y: o.y + s, z: o.z + s },"),document.writeln("		{ x: o.x - s, y: o.y + s, z: o.z + 0 },"),document.writeln("		{ x: o.x - s, y: o.y + s, z: o.z - s },"),document.writeln("		// Middle"),document.writeln("		{ x: o.x + s, y: o.y + 0, z: o.z + s },"),document.writeln("		{ x: o.x + s, y: o.y + 0, z: o.z - s },"),document.writeln("		{ x: o.x - s, y: o.y + 0, z: o.z + s },"),document.writeln("		{ x: o.x - s, y: o.y + 0, z: o.z - s }"),document.writeln("	];"),document.writeln("}"),document.writeln(""),document.writeln("// Helper to optimize models by merging duplicate vertices within a threshold,"),document.writeln("// and removing all polys that share the same vertices."),document.writeln("// Directly mutates the model."),document.writeln("function optimizeModel(model, threshold = 0.0001) {"),document.writeln("	const { vertices, polys } = model;"),document.writeln(""),document.writeln("	const compareVertices = (v1, v2) =>"),document.writeln("		Math.abs(v1.x - v2.x) < threshold &&"),document.writeln("		Math.abs(v1.y - v2.y) < threshold &&"),document.writeln("		Math.abs(v1.z - v2.z) < threshold;"),document.writeln(""),document.writeln("	const comparePolys = (p1, p2) => {"),document.writeln("		const v1 = p1.vIndexes;"),document.writeln("		const v2 = p2.vIndexes;"),document.writeln("		return ("),document.writeln("			(v1[0] === v2[0] || v1[0] === v2[1] || v1[0] === v2[2] || v1[0] === v2[3]) &&"),document.writeln("			(v1[1] === v2[0] || v1[1] === v2[1] || v1[1] === v2[2] || v1[1] === v2[3]) &&"),document.writeln("			(v1[2] === v2[0] || v1[2] === v2[1] || v1[2] === v2[2] || v1[2] === v2[3]) &&"),document.writeln("			(v1[3] === v2[0] || v1[3] === v2[1] || v1[3] === v2[2] || v1[3] === v2[3])"),document.writeln("		);"),document.writeln("	};"),document.writeln(""),document.writeln("	vertices.forEach((v, i) => {"),document.writeln("		v.originalIndexes = [i];"),document.writeln("	});"),document.writeln(""),document.writeln("	for (let i = vertices.length - 1; i >= 0; i--) {"),document.writeln("		for (let ii = i - 1; ii >= 0; ii--) {"),document.writeln("			const v1 = vertices[i];"),document.writeln("			const v2 = vertices[ii];"),document.writeln("			if (compareVertices(v1, v2)) {"),document.writeln("				vertices.splice(i, 1);"),document.writeln("				v2.originalIndexes.push(...v1.originalIndexes);"),document.writeln("				break;"),document.writeln("			}"),document.writeln("		}"),document.writeln("	}"),document.writeln(""),document.writeln("	vertices.forEach((v, i) => {"),document.writeln("		polys.forEach((p) => {"),document.writeln("			p.vIndexes.forEach((vi, ii, arr) => {"),document.writeln("				const vo = v.originalIndexes;"),document.writeln("				if (vo.includes(vi)) {"),document.writeln("					arr[ii] = i;"),document.writeln("				}"),document.writeln("			});"),document.writeln("		});"),document.writeln("	});"),document.writeln(""),document.writeln("	polys.forEach((p) => {"),document.writeln("		const vi = p.vIndexes;"),document.writeln("		p.sum = vi[0] + vi[1] + vi[2] + vi[3];"),document.writeln("	});"),document.writeln("	polys.sort((a, b) => b.sum - a.sum);"),document.writeln(""),document.writeln("	// Assumptions:"),document.writeln("	// 1. Each poly will either have no duplicates or 1 duplicate."),document.writeln("	// 2. If two polys are equal, they are both hidden (two cubes touching),"),document.writeln("	//    therefore both can be removed."),document.writeln("	for (let i = polys.length - 1; i >= 0; i--) {"),document.writeln("		for (let ii = i - 1; ii >= 0; ii--) {"),document.writeln("			const p1 = polys[i];"),document.writeln("			const p2 = polys[ii];"),document.writeln("			if (p1.sum !== p2.sum) break;"),document.writeln("			if (comparePolys(p1, p2)) {"),document.writeln("				polys.splice(i, 1);"),document.writeln("				polys.splice(ii, 1);"),document.writeln("				i--;"),document.writeln("				break;"),document.writeln("			}"),document.writeln("		}"),document.writeln("	}"),document.writeln(""),document.writeln("	return model;"),document.writeln("}"),document.writeln(""),document.writeln("// Entity.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("class Entity {"),document.writeln("	constructor({ model, color, wireframe = false }) {"),document.writeln("		const vertices = cloneVertices(model.vertices);"),document.writeln("		const shadowVertices = cloneVertices(model.vertices);"),document.writeln("		const colorHex = colorToHex(color);"),document.writeln("		const darkColorHex = shadeColor(color, 0.4);"),document.writeln(""),document.writeln("		const polys = model.polys.map((p) => ({"),document.writeln("			vertices: p.vIndexes.map((vIndex) => vertices[vIndex]),"),document.writeln("			color: color, // custom rgb color object"),document.writeln("			wireframe: wireframe,"),document.writeln("			strokeWidth: wireframe ? 2 : 0, // Set to non-zero value to draw stroke"),document.writeln("			strokeColor: colorHex, // must be a CSS color string"),document.writeln("			strokeColorDark: darkColorHex, // must be a CSS color string"),document.writeln("			depth: 0,"),document.writeln("			middle: { x: 0, y: 0, z: 0 },"),document.writeln("			normalWorld: { x: 0, y: 0, z: 0 },"),document.writeln("			normalCamera: { x: 0, y: 0, z: 0 }"),document.writeln("		}));"),document.writeln(""),document.writeln("		const shadowPolys = model.polys.map((p) => ({"),document.writeln("			vertices: p.vIndexes.map((vIndex) => shadowVertices[vIndex]),"),document.writeln("			wireframe: wireframe,"),document.writeln("			normalWorld: { x: 0, y: 0, z: 0 }"),document.writeln("		}));"),document.writeln(""),document.writeln("		this.projected = {}; // Will store 2D projected data"),document.writeln("		this.model = model;"),document.writeln("		this.vertices = vertices;"),document.writeln("		this.polys = polys;"),document.writeln("		this.shadowVertices = shadowVertices;"),document.writeln("		this.shadowPolys = shadowPolys;"),document.writeln("		this.reset();"),document.writeln("	}"),document.writeln(""),document.writeln("	// Better names: resetEntity, resetTransform, resetEntityTransform"),document.writeln("	reset() {"),document.writeln("		this.x = 0;"),document.writeln("		this.y = 0;"),document.writeln("		this.z = 0;"),document.writeln("		this.xD = 0;"),document.writeln("		this.yD = 0;"),document.writeln("		this.zD = 0;"),document.writeln(""),document.writeln("		this.rotateX = 0;"),document.writeln("		this.rotateY = 0;"),document.writeln("		this.rotateZ = 0;"),document.writeln("		this.rotateXD = 0;"),document.writeln("		this.rotateYD = 0;"),document.writeln("		this.rotateZD = 0;"),document.writeln(""),document.writeln("		this.scaleX = 1;"),document.writeln("		this.scaleY = 1;"),document.writeln("		this.scaleZ = 1;"),document.writeln(""),document.writeln("		this.projected.x = 0;"),document.writeln("		this.projected.y = 0;"),document.writeln("	}"),document.writeln(""),document.writeln("	transform() {"),document.writeln("		transformVertices("),document.writeln("			this.model.vertices,"),document.writeln("			this.vertices,"),document.writeln("			this.x,"),document.writeln("			this.y,"),document.writeln("			this.z,"),document.writeln("			this.rotateX,"),document.writeln("			this.rotateY,"),document.writeln("			this.rotateZ,"),document.writeln("			this.scaleX,"),document.writeln("			this.scaleY,"),document.writeln("			this.scaleZ"),document.writeln("		);"),document.writeln(""),document.writeln("		copyVerticesTo(this.vertices, this.shadowVertices);"),document.writeln("	}"),document.writeln(""),document.writeln("	// Projects origin point, stored as `projected` property."),document.writeln("	project() {"),document.writeln("		projectVertexTo(this, this.projected);"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("// getTarget.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("// All active targets"),document.writeln("const targets = [];"),document.writeln(""),document.writeln("// Pool target instances by color, using a Map."),document.writeln("// keys are color objects, and values are arrays of targets."),document.writeln("// Also pool wireframe instances separately."),document.writeln("const targetPool = new Map(allColors.map((c) => [c, []]));"),document.writeln("const targetWireframePool = new Map(allColors.map((c) => [c, []]));"),document.writeln(""),document.writeln("const getTarget = (() => {"),document.writeln("	const slowmoSpawner = makeSpawner({"),document.writeln("		chance: 0.5,"),document.writeln("		cooldownPerSpawn: 10000,"),document.writeln("		maxSpawns: 1"),document.writeln("	});"),document.writeln(""),document.writeln("	let doubleStrong = false;"),document.writeln("	const strongSpawner = makeSpawner({"),document.writeln("		chance: 0.3,"),document.writeln("		cooldownPerSpawn: 12000,"),document.writeln("		maxSpawns: 1"),document.writeln("	});"),document.writeln(""),document.writeln("	const spinnerSpawner = makeSpawner({"),document.writeln("		chance: 0.1,"),document.writeln("		cooldownPerSpawn: 10000,"),document.writeln("		maxSpawns: 1"),document.writeln("	});"),document.writeln(""),document.writeln("	// Cached array instances, no need to allocate every time."),document.writeln("	const axisOptions = ["),document.writeln('		["x", "y"],'),document.writeln('		["y", "z"],'),document.writeln('		["z", "x"]'),document.writeln("	];"),document.writeln(""),document.writeln("	function getTargetOfStyle(color, wireframe) {"),document.writeln("		const pool = wireframe ? targetWireframePool : targetPool;"),document.writeln("		let target = pool.get(color).pop();"),document.writeln("		if (!target) {"),document.writeln("			target = new Entity({"),document.writeln("				model: optimizeModel("),document.writeln("					makeRecursiveCubeModel({"),document.writeln("						recursionLevel: 1,"),document.writeln("						splitFn: mengerSpongeSplit,"),document.writeln("						scale: targetRadius"),document.writeln("					})"),document.writeln("				),"),document.writeln("				color: color,"),document.writeln("				wireframe: wireframe"),document.writeln("			});"),document.writeln(""),document.writeln("			// Init any properties that will be used."),document.writeln("			// These will not be automatically reset when recycled."),document.writeln("			target.color = color;"),document.writeln("			target.wireframe = wireframe;"),document.writeln("			// Some properties don't have their final value yet."),document.writeln("			// Initialize with any value of the right type."),document.writeln("			target.hit = false;"),document.writeln("			target.maxHealth = 0;"),document.writeln("			target.health = 0;"),document.writeln("		}"),document.writeln("		return target;"),document.writeln("	}"),document.writeln(""),document.writeln("	return function getTarget() {"),document.writeln("		if (doubleStrong && state.game.score <= doubleStrongEnableScore) {"),document.writeln("			doubleStrong = false;"),document.writeln("			// Spawner is reset automatically when game resets."),document.writeln("		} else if (!doubleStrong && state.game.score > doubleStrongEnableScore) {"),document.writeln("			doubleStrong = true;"),document.writeln("			strongSpawner.mutate({ maxSpawns: 2 });"),document.writeln("		}"),document.writeln(""),document.writeln("		// Target Parameters"),document.writeln("		// --------------------------------"),document.writeln("		let color = pickOne([BLUE, GREEN, ORANGE]);"),document.writeln("		let wireframe = false;"),document.writeln("		let health = 1;"),document.writeln("		let maxHealth = 3;"),document.writeln("		const spinner ="),document.writeln("			state.game.cubeCount >= spinnerThreshold &&"),document.writeln("			isInGame() &&"),document.writeln("			spinnerSpawner.shouldSpawn();"),document.writeln(""),document.writeln("		// Target Parameter Overrides"),document.writeln("		// --------------------------------"),document.writeln("		if (state.game.cubeCount >= slowmoThreshold && slowmoSpawner.shouldSpawn()) {"),document.writeln("			color = BLUE;"),document.writeln("			wireframe = true;"),document.writeln("		} else if ("),document.writeln("			state.game.cubeCount >= strongThreshold &&"),document.writeln("			strongSpawner.shouldSpawn()"),document.writeln("		) {"),document.writeln("			color = PINK;"),document.writeln("			health = 3;"),document.writeln("		}"),document.writeln(""),document.writeln("		// Target Creation"),document.writeln("		// --------------------------------"),document.writeln("		const target = getTargetOfStyle(color, wireframe);"),document.writeln("		target.hit = false;"),document.writeln("		target.maxHealth = maxHealth;"),document.writeln("		target.health = health;"),document.writeln("		updateTargetHealth(target, 0);"),document.writeln(""),document.writeln("		const spinSpeeds = [Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05];"),document.writeln(""),document.writeln("		if (spinner) {"),document.writeln("			// Ends up spinning a random axis"),document.writeln("			spinSpeeds[0] = -0.25;"),document.writeln("			spinSpeeds[1] = 0;"),document.writeln("			target.rotateZ = random(0, TAU);"),document.writeln("		}"),document.writeln(""),document.writeln("		const axes = pickOne(axisOptions);"),document.writeln(""),document.writeln("		spinSpeeds.forEach((spinSpeed, i) => {"),document.writeln("			switch (axes[i]) {"),document.writeln('				case "x":'),document.writeln("					target.rotateXD = spinSpeed;"),document.writeln("					break;"),document.writeln('				case "y":'),document.writeln("					target.rotateYD = spinSpeed;"),document.writeln("					break;"),document.writeln('				case "z":'),document.writeln("					target.rotateZD = spinSpeed;"),document.writeln("					break;"),document.writeln("			}"),document.writeln("		});"),document.writeln(""),document.writeln("		return target;"),document.writeln("	};"),document.writeln("})();"),document.writeln(""),document.writeln("const updateTargetHealth = (target, healthDelta) => {"),document.writeln("	target.health += healthDelta;"),document.writeln("	// Only update stroke on non-wireframe targets."),document.writeln('	// Showing "glue" is a temporary attempt to display health. For now, there\'s'),document.writeln("	// no reason to have wireframe targets with high health, so we're fine."),document.writeln("	if (!target.wireframe) {"),document.writeln("		const strokeWidth = target.health - 1;"),document.writeln("		const strokeColor = makeTargetGlueColor(target);"),document.writeln("		for (let p of target.polys) {"),document.writeln("			p.strokeWidth = strokeWidth;"),document.writeln("			p.strokeColor = strokeColor;"),document.writeln("		}"),document.writeln("	}"),document.writeln("};"),document.writeln(""),document.writeln("const returnTarget = (target) => {"),document.writeln("	target.reset();"),document.writeln("	const pool = target.wireframe ? targetWireframePool : targetPool;"),document.writeln("	pool.get(target.color).push(target);"),document.writeln("};"),document.writeln(""),document.writeln("function resetAllTargets() {"),document.writeln("	while (targets.length) {"),document.writeln("		returnTarget(targets.pop());"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("// createBurst.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("// Track all active fragments"),document.writeln("const frags = [];"),document.writeln("// Pool inactive fragments by color, using a Map."),document.writeln("// keys are color objects, and values are arrays of fragments."),document.writeln("// // Also pool wireframe instances separately."),document.writeln("const fragPool = new Map(allColors.map((c) => [c, []]));"),document.writeln("const fragWireframePool = new Map(allColors.map((c) => [c, []]));"),document.writeln(""),document.writeln("const createBurst = (() => {"),document.writeln("	// Precompute some private data to be reused for all bursts."),document.writeln("	const basePositions = mengerSpongeSplit({ x: 0, y: 0, z: 0 }, fragRadius * 2);"),document.writeln("	const positions = cloneVertices(basePositions);"),document.writeln("	const prevPositions = cloneVertices(basePositions);"),document.writeln("	const velocities = cloneVertices(basePositions);"),document.writeln(""),document.writeln("	const basePositionNormals = basePositions.map(normalize);"),document.writeln("	const positionNormals = cloneVertices(basePositionNormals);"),document.writeln(""),document.writeln("	const fragCount = basePositions.length;"),document.writeln(""),document.writeln("	function getFragForTarget(target) {"),document.writeln("		const pool = target.wireframe ? fragWireframePool : fragPool;"),document.writeln("		let frag = pool.get(target.color).pop();"),document.writeln("		if (!frag) {"),document.writeln("			frag = new Entity({"),document.writeln("				model: makeCubeModel({ scale: fragRadius }),"),document.writeln("				color: target.color,"),document.writeln("				wireframe: target.wireframe"),document.writeln("			});"),document.writeln("			frag.color = target.color;"),document.writeln("			frag.wireframe = target.wireframe;"),document.writeln("		}"),document.writeln("		return frag;"),document.writeln("	}"),document.writeln(""),document.writeln("	return (target, force = 1) => {"),document.writeln("		// Calculate fragment positions, and what would have been the previous positions"),document.writeln("		// when still a part of the larger target."),document.writeln("		transformVertices("),document.writeln("			basePositions,"),document.writeln("			positions,"),document.writeln("			target.x,"),document.writeln("			target.y,"),document.writeln("			target.z,"),document.writeln("			target.rotateX,"),document.writeln("			target.rotateY,"),document.writeln("			target.rotateZ,"),document.writeln("			1,"),document.writeln("			1,"),document.writeln("			1"),document.writeln("		);"),document.writeln("		transformVertices("),document.writeln("			basePositions,"),document.writeln("			prevPositions,"),document.writeln("			target.x - target.xD,"),document.writeln("			target.y - target.yD,"),document.writeln("			target.z - target.zD,"),document.writeln("			target.rotateX - target.rotateXD,"),document.writeln("			target.rotateY - target.rotateYD,"),document.writeln("			target.rotateZ - target.rotateZD,"),document.writeln("			1,"),document.writeln("			1,"),document.writeln("			1"),document.writeln("		);"),document.writeln(""),document.writeln("		// Compute velocity of each fragment, based on previous positions."),document.writeln("		// Will write to `velocities` array."),document.writeln("		for (let i = 0; i < fragCount; i++) {"),document.writeln("			const position = positions[i];"),document.writeln("			const prevPosition = prevPositions[i];"),document.writeln("			const velocity = velocities[i];"),document.writeln(""),document.writeln("			velocity.x = position.x - prevPosition.x;"),document.writeln("			velocity.y = position.y - prevPosition.y;"),document.writeln("			velocity.z = position.z - prevPosition.z;"),document.writeln("		}"),document.writeln(""),document.writeln("		// Apply target rotation to normals"),document.writeln("		transformVertices("),document.writeln("			basePositionNormals,"),document.writeln("			positionNormals,"),document.writeln("			0,"),document.writeln("			0,"),document.writeln("			0,"),document.writeln("			target.rotateX,"),document.writeln("			target.rotateY,"),document.writeln("			target.rotateZ,"),document.writeln("			1,"),document.writeln("			1,"),document.writeln("			1"),document.writeln("		);"),document.writeln(""),document.writeln("		for (let i = 0; i < fragCount; i++) {"),document.writeln("			const position = positions[i];"),document.writeln("			const velocity = velocities[i];"),document.writeln("			const normal = positionNormals[i];"),document.writeln(""),document.writeln("			const frag = getFragForTarget(target);"),document.writeln(""),document.writeln("			frag.x = position.x;"),document.writeln("			frag.y = position.y;"),document.writeln("			frag.z = position.z;"),document.writeln("			frag.rotateX = target.rotateX;"),document.writeln("			frag.rotateY = target.rotateY;"),document.writeln("			frag.rotateZ = target.rotateZ;"),document.writeln(""),document.writeln("			const burstSpeed = 2 * force;"),document.writeln("			const randSpeed = 2 * force;"),document.writeln("			const rotateScale = 0.015;"),document.writeln("			frag.xD = velocity.x + normal.x * burstSpeed + Math.random() * randSpeed;"),document.writeln("			frag.yD = velocity.y + normal.y * burstSpeed + Math.random() * randSpeed;"),document.writeln("			frag.zD = velocity.z + normal.z * burstSpeed + Math.random() * randSpeed;"),document.writeln("			frag.rotateXD = frag.xD * rotateScale;"),document.writeln("			frag.rotateYD = frag.yD * rotateScale;"),document.writeln("			frag.rotateZD = frag.zD * rotateScale;"),document.writeln(""),document.writeln("			frags.push(frag);"),document.writeln("		}"),document.writeln("	};"),document.writeln("})();"),document.writeln(""),document.writeln("const returnFrag = (frag) => {"),document.writeln("	frag.reset();"),document.writeln("	const pool = frag.wireframe ? fragWireframePool : fragPool;"),document.writeln("	pool.get(frag.color).push(frag);"),document.writeln("};"),document.writeln(""),document.writeln("// sparks.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("const sparks = [];"),document.writeln("const sparkPool = [];"),document.writeln(""),document.writeln("function addSpark(x, y, xD, yD) {"),document.writeln("	const spark = sparkPool.pop() || {};"),document.writeln(""),document.writeln("	spark.x = x + xD * 0.5;"),document.writeln("	spark.y = y + yD * 0.5;"),document.writeln("	spark.xD = xD;"),document.writeln("	spark.yD = yD;"),document.writeln("	spark.life = random(200, 300);"),document.writeln("	spark.maxLife = spark.life;"),document.writeln(""),document.writeln("	sparks.push(spark);"),document.writeln(""),document.writeln("	return spark;"),document.writeln("}"),document.writeln(""),document.writeln("// Spherical spark burst"),document.writeln("function sparkBurst(x, y, count, maxSpeed) {"),document.writeln("	const angleInc = TAU / count;"),document.writeln("	for (let i = 0; i < count; i++) {"),document.writeln("		const angle = i * angleInc + angleInc * Math.random();"),document.writeln("		const speed = (1 - Math.random() ** 3) * maxSpeed;"),document.writeln("		addSpark(x, y, Math.sin(angle) * speed, Math.cos(angle) * speed);"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln('// Make a target "leak" sparks from all vertices.'),document.writeln('// This is used to create the effect of target glue "shedding".'),document.writeln("let glueShedVertices;"),document.writeln("function glueShedSparks(target) {"),document.writeln("	if (!glueShedVertices) {"),document.writeln("		glueShedVertices = cloneVertices(target.vertices);"),document.writeln("	} else {"),document.writeln("		copyVerticesTo(target.vertices, glueShedVertices);"),document.writeln("	}"),document.writeln(""),document.writeln("	glueShedVertices.forEach((v) => {"),document.writeln("		if (Math.random() < 0.4) {"),document.writeln("			projectVertex(v);"),document.writeln("			addSpark(v.x, v.y, random(-12, 12), random(-12, 12));"),document.writeln("		}"),document.writeln("	});"),document.writeln("}"),document.writeln(""),document.writeln("function returnSpark(spark) {"),document.writeln("	sparkPool.push(spark);"),document.writeln("}"),document.writeln(""),document.writeln("// hud.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln('const hudContainerNode = $(".hud");'),document.writeln(""),document.writeln("function setHudVisibility(visible) {"),document.writeln("	if (visible) {"),document.writeln('		hudContainerNode.style.display = "block";'),document.writeln("	} else {"),document.writeln('		hudContainerNode.style.display = "none";'),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("///////////"),document.writeln("// Score //"),document.writeln("///////////"),document.writeln('const scoreNode = $(".score-lbl");'),document.writeln('const cubeCountNode = $(".cube-count-lbl");'),document.writeln(""),document.writeln("function renderScoreHud() {"),document.writeln("	if (isCasualGame()) {"),document.writeln('		scoreNode.style.display = "none";'),document.writeln("		cubeCountNode.style.opacity = 1;"),document.writeln("	} else {"),document.writeln("		scoreNode.innerText = `SCORE: ${state.game.score}`;"),document.writeln('		scoreNode.style.display = "block";'),document.writeln("		cubeCountNode.style.opacity = 0.65;"),document.writeln("	}"),document.writeln("	cubeCountNode.innerText = `CUBES SMASHED: ${state.game.cubeCount}`;"),document.writeln("}"),document.writeln(""),document.writeln("renderScoreHud();"),document.writeln(""),document.writeln("//////////////////"),document.writeln("// Pause Button //"),document.writeln("//////////////////"),document.writeln(""),document.writeln('handlePointerDown($(".pause-btn"), () => pauseGame());'),document.writeln(""),document.writeln("////////////////////"),document.writeln("// Slow-Mo Status //"),document.writeln("////////////////////"),document.writeln(""),document.writeln('const slowmoNode = $(".slowmo");'),document.writeln('const slowmoBarNode = $(".slowmo__bar");'),document.writeln(""),document.writeln("function renderSlowmoStatus(percentRemaining) {"),document.writeln("	slowmoNode.style.opacity = percentRemaining === 0 ? 0 : 1;"),document.writeln("	slowmoBarNode.style.transform = `scaleX(${percentRemaining.toFixed(3)})`;"),document.writeln("}"),document.writeln(""),document.writeln("// menus.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("// Top-level menu containers"),document.writeln('const menuContainerNode = $(".menus");'),document.writeln('const menuMainNode = $(".menu--main");'),document.writeln('const menuPauseNode = $(".menu--pause");'),document.writeln('const menuScoreNode = $(".menu--score");'),document.writeln(""),document.writeln('const finalScoreLblNode = $(".final-score-lbl");'),document.writeln('const highScoreLblNode = $(".high-score-lbl");'),document.writeln(""),document.writeln("function showMenu(node) {"),document.writeln('	node.classList.add("active");'),document.writeln("}"),document.writeln(""),document.writeln("function hideMenu(node) {"),document.writeln('	node.classList.remove("active");'),document.writeln("}"),document.writeln(""),document.writeln("function renderMenus() {"),document.writeln("	hideMenu(menuMainNode);"),document.writeln("	hideMenu(menuPauseNode);"),document.writeln("	hideMenu(menuScoreNode);"),document.writeln(""),document.writeln("	switch (state.menus.active) {"),document.writeln("		case MENU_MAIN:"),document.writeln("			showMenu(menuMainNode);"),document.writeln("			break;"),document.writeln("		case MENU_PAUSE:"),document.writeln("			showMenu(menuPauseNode);"),document.writeln("			break;"),document.writeln("		case MENU_SCORE:"),document.writeln("			finalScoreLblNode.textContent = formatNumber(state.game.score);"),document.writeln("			if (isNewHighScore()) {"),document.writeln('				highScoreLblNode.textContent = "New High Score!";'),document.writeln("			} else {"),document.writeln("				highScoreLblNode.textContent = `High Score: ${formatNumber("),document.writeln("					getHighScore()"),document.writeln("				)}`;"),document.writeln("			}"),document.writeln("			showMenu(menuScoreNode);"),document.writeln("			break;"),document.writeln("	}"),document.writeln(""),document.writeln("	setHudVisibility(!isMenuVisible());"),document.writeln('	menuContainerNode.classList.toggle("has-active", isMenuVisible());'),document.writeln("	menuContainerNode.classList.toggle("),document.writeln('		"interactive-mode",'),document.writeln("		isMenuVisible() && pointerIsDown"),document.writeln("	);"),document.writeln("}"),document.writeln(""),document.writeln("renderMenus();"),document.writeln(""),document.writeln("////////////////////"),document.writeln("// Button Actions //"),document.writeln("////////////////////"),document.writeln(""),document.writeln("// Main Menu"),document.writeln('handleClick($(".play-normal-btn"), () => {'),document.writeln("	setGameMode(GAME_MODE_RANKED);"),document.writeln("	setActiveMenu(null);"),document.writeln("	resetGame();"),document.writeln("});"),document.writeln(""),document.writeln('handleClick($(".play-casual-btn"), () => {'),document.writeln("	setGameMode(GAME_MODE_CASUAL);"),document.writeln("	setActiveMenu(null);"),document.writeln("	resetGame();"),document.writeln("});"),document.writeln(""),document.writeln("// Pause Menu"),document.writeln('handleClick($(".resume-btn"), () => resumeGame());'),document.writeln('handleClick($(".menu-btn--pause"), () => setActiveMenu(MENU_MAIN));'),document.writeln(""),document.writeln("// Score Menu"),document.writeln('handleClick($(".play-again-btn"), () => {'),document.writeln("	setActiveMenu(null);"),document.writeln("	resetGame();"),document.writeln("});"),document.writeln(""),document.writeln('handleClick($(".menu-btn--score"), () => setActiveMenu(MENU_MAIN));'),document.writeln(""),document.writeln("////////////////////"),document.writeln("// Button Actions //"),document.writeln("////////////////////"),document.writeln(""),document.writeln("// Main Menu"),document.writeln('handleClick($(".play-normal-btn"), () => {'),document.writeln("	setGameMode(GAME_MODE_RANKED);"),document.writeln("	setActiveMenu(null);"),document.writeln("	resetGame();"),document.writeln("});"),document.writeln(""),document.writeln('handleClick($(".play-casual-btn"), () => {'),document.writeln("	setGameMode(GAME_MODE_CASUAL);"),document.writeln("	setActiveMenu(null);"),document.writeln("	resetGame();"),document.writeln("});"),document.writeln(""),document.writeln("// Pause Menu"),document.writeln('handleClick($(".resume-btn"), () => resumeGame());'),document.writeln('handleClick($(".menu-btn--pause"), () => setActiveMenu(MENU_MAIN));'),document.writeln(""),document.writeln("// Score Menu"),document.writeln('handleClick($(".play-again-btn"), () => {'),document.writeln("	setActiveMenu(null);"),document.writeln("	resetGame();"),document.writeln("});"),document.writeln(""),document.writeln('handleClick($(".menu-btn--score"), () => setActiveMenu(MENU_MAIN));'),document.writeln(""),document.writeln("// actions.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("//////////////////"),document.writeln("// MENU ACTIONS //"),document.writeln("//////////////////"),document.writeln(""),document.writeln("function setActiveMenu(menu) {"),document.writeln("	state.menus.active = menu;"),document.writeln("	renderMenus();"),document.writeln("}"),document.writeln(""),document.writeln("/////////////////"),document.writeln("// HUD ACTIONS //"),document.writeln("/////////////////"),document.writeln(""),document.writeln("function setScore(score) {"),document.writeln("	state.game.score = score;"),document.writeln("	renderScoreHud();"),document.writeln("}"),document.writeln(""),document.writeln("function incrementScore(inc) {"),document.writeln("	if (isInGame()) {"),document.writeln("		state.game.score += inc;"),document.writeln("		if (state.game.score < 0) {"),document.writeln("			state.game.score = 0;"),document.writeln("		}"),document.writeln("		renderScoreHud();"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("function setCubeCount(count) {"),document.writeln("	state.game.cubeCount = count;"),document.writeln("	renderScoreHud();"),document.writeln("}"),document.writeln(""),document.writeln("function incrementCubeCount(inc) {"),document.writeln("	if (isInGame()) {"),document.writeln("		state.game.cubeCount += inc;"),document.writeln("		renderScoreHud();"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("//////////////////"),document.writeln("// GAME ACTIONS //"),document.writeln("//////////////////"),document.writeln(""),document.writeln("function setGameMode(mode) {"),document.writeln("	state.game.mode = mode;"),document.writeln("}"),document.writeln(""),document.writeln("function resetGame() {"),document.writeln("	resetAllTargets();"),document.writeln("	state.game.time = 0;"),document.writeln("	resetAllCooldowns();"),document.writeln("	setScore(0);"),document.writeln("	setCubeCount(0);"),document.writeln("	spawnTime = getSpawnDelay();"),document.writeln("}"),document.writeln(""),document.writeln("function pauseGame() {"),document.writeln("	isInGame() && setActiveMenu(MENU_PAUSE);"),document.writeln("}"),document.writeln(""),document.writeln("function resumeGame() {"),document.writeln("	isPaused() && setActiveMenu(null);"),document.writeln("}"),document.writeln(""),document.writeln("function endGame() {"),document.writeln("	handleCanvasPointerUp();"),document.writeln("	if (isNewHighScore()) {"),document.writeln("		setHighScore(state.game.score);"),document.writeln("	}"),document.writeln("	setActiveMenu(MENU_SCORE);"),document.writeln("}"),document.writeln(""),document.writeln("////////////////////////"),document.writeln("// KEYBOARD SHORTCUTS //"),document.writeln("////////////////////////"),document.writeln(""),document.writeln('window.addEventListener("keydown", (event) => {'),document.writeln('	if (event.key === "p") {'),document.writeln("		isPaused() ? resumeGame() : pauseGame();"),document.writeln("	}"),document.writeln("});"),document.writeln(""),document.writeln("// tick.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("let spawnTime = 0;"),document.writeln("const maxSpawnX = 450;"),document.writeln("const pointerDelta = { x: 0, y: 0 };"),document.writeln("const pointerDeltaScaled = { x: 0, y: 0 };"),document.writeln(""),document.writeln("// Temp slowmo state. Should be relocated once this stabilizes."),document.writeln("const slowmoDuration = 1500;"),document.writeln("let slowmoRemaining = 0;"),document.writeln("let spawnExtra = 0;"),document.writeln("const spawnExtraDelay = 300;"),document.writeln("let targetSpeed = 1;"),document.writeln(""),document.writeln("function tick(width, height, simTime, simSpeed, lag) {"),document.writeln('	PERF_START("frame");'),document.writeln('	PERF_START("tick");'),document.writeln(""),document.writeln("	state.game.time += simTime;"),document.writeln(""),document.writeln("	if (slowmoRemaining > 0) {"),document.writeln("		slowmoRemaining -= simTime;"),document.writeln("		if (slowmoRemaining < 0) {"),document.writeln("			slowmoRemaining = 0;"),document.writeln("		}"),document.writeln("		targetSpeed = pointerIsDown ? 0.075 : 0.3;"),document.writeln("	} else {"),document.writeln("		const menuPointerDown = isMenuVisible() && pointerIsDown;"),document.writeln("		targetSpeed = menuPointerDown ? 0.025 : 1;"),document.writeln("	}"),document.writeln(""),document.writeln("	renderSlowmoStatus(slowmoRemaining / slowmoDuration);"),document.writeln(""),document.writeln("	gameSpeed += ((targetSpeed - gameSpeed) / 22) * lag;"),document.writeln("	gameSpeed = clamp(gameSpeed, 0, 1);"),document.writeln(""),document.writeln("	const centerX = width / 2;"),document.writeln("	const centerY = height / 2;"),document.writeln(""),document.writeln("	const simAirDrag = 1 - airDrag * simSpeed;"),document.writeln("	const simAirDragSpark = 1 - airDragSpark * simSpeed;"),document.writeln(""),document.writeln("	// Pointer Tracking"),document.writeln("	// -------------------"),document.writeln(""),document.writeln("	// Compute speed and x/y deltas."),document.writeln('	// There is also a "scaled" variant taking game speed into account. This serves two purposes:'),document.writeln("	//  - Lag won't create large spikes in speed/deltas"),document.writeln('	//  - In slow mo, speed is increased proportionately to match "reality". Without this boost,'),document.writeln("	//    it feels like your actions are dampened in slow mo."),document.writeln("	const forceMultiplier = 1 / (simSpeed * 0.75 + 0.25);"),document.writeln("	pointerDelta.x = 0;"),document.writeln("	pointerDelta.y = 0;"),document.writeln("	pointerDeltaScaled.x = 0;"),document.writeln("	pointerDeltaScaled.y = 0;"),document.writeln("	const lastPointer = touchPoints[touchPoints.length - 1];"),document.writeln(""),document.writeln("	if (pointerIsDown && lastPointer && !lastPointer.touchBreak) {"),document.writeln("		pointerDelta.x = pointerScene.x - lastPointer.x;"),document.writeln("		pointerDelta.y = pointerScene.y - lastPointer.y;"),document.writeln("		pointerDeltaScaled.x = pointerDelta.x * forceMultiplier;"),document.writeln("		pointerDeltaScaled.y = pointerDelta.y * forceMultiplier;"),document.writeln("	}"),document.writeln("	const pointerSpeed = Math.hypot(pointerDelta.x, pointerDelta.y);"),document.writeln("	const pointerSpeedScaled = pointerSpeed * forceMultiplier;"),document.writeln(""),document.writeln("	// Track points for later calculations, including drawing trail."),document.writeln("	touchPoints.forEach((p) => (p.life -= simTime));"),document.writeln(""),document.writeln("	if (pointerIsDown) {"),document.writeln("		touchPoints.push({"),document.writeln("			x: pointerScene.x,"),document.writeln("			y: pointerScene.y,"),document.writeln("			life: touchPointLife"),document.writeln("		});"),document.writeln("	}"),document.writeln(""),document.writeln("	while (touchPoints[0] && touchPoints[0].life <= 0) {"),document.writeln("		touchPoints.shift();"),document.writeln("	}"),document.writeln(""),document.writeln("	// Entity Manipulation"),document.writeln("	// --------------------"),document.writeln('	PERF_START("entities");'),document.writeln(""),document.writeln("	// Spawn targets"),document.writeln("	spawnTime -= simTime;"),document.writeln("	if (spawnTime <= 0) {"),document.writeln("		if (spawnExtra > 0) {"),document.writeln("			spawnExtra--;"),document.writeln("			spawnTime = spawnExtraDelay;"),document.writeln("		} else {"),document.writeln("			spawnTime = getSpawnDelay();"),document.writeln("		}"),document.writeln("		const target = getTarget();"),document.writeln("		const spawnRadius = Math.min(centerX * 0.8, maxSpawnX);"),document.writeln("		target.x = Math.random() * spawnRadius * 2 - spawnRadius;"),document.writeln("		target.y = centerY + targetHitRadius * 2;"),document.writeln("		target.z = Math.random() * targetRadius * 2 - targetRadius;"),document.writeln("		target.xD = Math.random() * ((target.x * -2) / 120);"),document.writeln("		target.yD = -20;"),document.writeln("		targets.push(target);"),document.writeln("	}"),document.writeln(""),document.writeln("	// Animate targets and remove when offscreen"),document.writeln("	const leftBound = -centerX + targetRadius;"),document.writeln("	const rightBound = centerX - targetRadius;"),document.writeln("	const ceiling = -centerY - 120;"),document.writeln("	const boundDamping = 0.4;"),document.writeln(""),document.writeln("	targetLoop: for (let i = targets.length - 1; i >= 0; i--) {"),document.writeln("		const target = targets[i];"),document.writeln("		target.x += target.xD * simSpeed;"),document.writeln("		target.y += target.yD * simSpeed;"),document.writeln(""),document.writeln("		if (target.y < ceiling) {"),document.writeln("			target.y = ceiling;"),document.writeln("			target.yD = 0;"),document.writeln("		}"),document.writeln(""),document.writeln("		if (target.x < leftBound) {"),document.writeln("			target.x = leftBound;"),document.writeln("			target.xD *= -boundDamping;"),document.writeln("		} else if (target.x > rightBound) {"),document.writeln("			target.x = rightBound;"),document.writeln("			target.xD *= -boundDamping;"),document.writeln("		}"),document.writeln(""),document.writeln("		if (target.z < backboardZ) {"),document.writeln("			target.z = backboardZ;"),document.writeln("			target.zD *= -boundDamping;"),document.writeln("		}"),document.writeln(""),document.writeln("		target.yD += gravity * simSpeed;"),document.writeln("		target.rotateX += target.rotateXD * simSpeed;"),document.writeln("		target.rotateY += target.rotateYD * simSpeed;"),document.writeln("		target.rotateZ += target.rotateZD * simSpeed;"),document.writeln("		target.transform();"),document.writeln("		target.project();"),document.writeln(""),document.writeln("		// Remove if offscreen"),document.writeln("		if (target.y > centerY + targetHitRadius * 2) {"),document.writeln("			targets.splice(i, 1);"),document.writeln("			returnTarget(target);"),document.writeln("			if (isInGame()) {"),document.writeln("				if (isCasualGame()) {"),document.writeln("					incrementScore(-25);"),document.writeln("				} else {"),document.writeln("					endGame();"),document.writeln("				}"),document.writeln("			}"),document.writeln("			continue;"),document.writeln("		}"),document.writeln(""),document.writeln("		// If pointer is moving really fast, we want to hittest multiple points along the path."),document.writeln("		// We can't use scaled pointer speed to determine this, since we care about actual screen"),document.writeln("		// distance covered."),document.writeln("		const hitTestCount = Math.ceil((pointerSpeed / targetRadius) * 2);"),document.writeln("		// Start loop at `1` and use `<=` check, so we skip 0% and end up at 100%."),document.writeln("		// This omits the previous point position, and includes the most recent."),document.writeln("		for (let ii = 1; ii <= hitTestCount; ii++) {"),document.writeln("			const percent = 1 - ii / hitTestCount;"),document.writeln("			const hitX = pointerScene.x - pointerDelta.x * percent;"),document.writeln("			const hitY = pointerScene.y - pointerDelta.y * percent;"),document.writeln("			const distance = Math.hypot("),document.writeln("				hitX - target.projected.x,"),document.writeln("				hitY - target.projected.y"),document.writeln("			);"),document.writeln(""),document.writeln("			if (distance <= targetHitRadius) {"),document.writeln("				// Hit! (though we don't want to allow hits on multiple sequential frames)"),document.writeln("				if (!target.hit) {"),document.writeln("					target.hit = true;"),document.writeln(""),document.writeln("					target.xD += pointerDeltaScaled.x * hitDampening;"),document.writeln("					target.yD += pointerDeltaScaled.y * hitDampening;"),document.writeln("					target.rotateXD += pointerDeltaScaled.y * 0.001;"),document.writeln("					target.rotateYD += pointerDeltaScaled.x * 0.001;"),document.writeln(""),document.writeln("					const sparkSpeed = 7 + pointerSpeedScaled * 0.125;"),document.writeln(""),document.writeln("					if (pointerSpeedScaled > minPointerSpeed) {"),document.writeln("						target.health--;"),document.writeln("						incrementScore(10);"),document.writeln(""),document.writeln("						if (target.health <= 0) {"),document.writeln("							incrementCubeCount(1);"),document.writeln("							createBurst(target, forceMultiplier);"),document.writeln("							sparkBurst(hitX, hitY, 8, sparkSpeed);"),document.writeln("							if (target.wireframe) {"),document.writeln("								slowmoRemaining = slowmoDuration;"),document.writeln("								spawnTime = 0;"),document.writeln("								spawnExtra = 2;"),document.writeln("							}"),document.writeln("							targets.splice(i, 1);"),document.writeln("							returnTarget(target);"),document.writeln("						} else {"),document.writeln("							sparkBurst(hitX, hitY, 8, sparkSpeed);"),document.writeln("							glueShedSparks(target);"),document.writeln("							updateTargetHealth(target, 0);"),document.writeln("						}"),document.writeln("					} else {"),document.writeln("						incrementScore(5);"),document.writeln("						sparkBurst(hitX, hitY, 3, sparkSpeed);"),document.writeln("					}"),document.writeln("				}"),document.writeln("				// Break the current loop and continue the outer loop."),document.writeln("				// This skips to processing the next target."),document.writeln("				continue targetLoop;"),document.writeln("			}"),document.writeln("		}"),document.writeln(""),document.writeln('		// This code will only run if target hasn\'t been "hit".'),document.writeln("		target.hit = false;"),document.writeln("	}"),document.writeln(""),document.writeln("	// Animate fragments and remove when offscreen."),document.writeln("	const fragBackboardZ = backboardZ + fragRadius;"),document.writeln("	// Allow fragments to move off-screen to sides for a while, since shadows are still visible."),document.writeln("	const fragLeftBound = -width;"),document.writeln("	const fragRightBound = width;"),document.writeln(""),document.writeln("	for (let i = frags.length - 1; i >= 0; i--) {"),document.writeln("		const frag = frags[i];"),document.writeln("		frag.x += frag.xD * simSpeed;"),document.writeln("		frag.y += frag.yD * simSpeed;"),document.writeln("		frag.z += frag.zD * simSpeed;"),document.writeln(""),document.writeln("		frag.xD *= simAirDrag;"),document.writeln("		frag.yD *= simAirDrag;"),document.writeln("		frag.zD *= simAirDrag;"),document.writeln(""),document.writeln("		if (frag.y < ceiling) {"),document.writeln("			frag.y = ceiling;"),document.writeln("			frag.yD = 0;"),document.writeln("		}"),document.writeln(""),document.writeln("		if (frag.z < fragBackboardZ) {"),document.writeln("			frag.z = fragBackboardZ;"),document.writeln("			frag.zD *= -boundDamping;"),document.writeln("		}"),document.writeln(""),document.writeln("		frag.yD += gravity * simSpeed;"),document.writeln("		frag.rotateX += frag.rotateXD * simSpeed;"),document.writeln("		frag.rotateY += frag.rotateYD * simSpeed;"),document.writeln("		frag.rotateZ += frag.rotateZD * simSpeed;"),document.writeln("		frag.transform();"),document.writeln("		frag.project();"),document.writeln(""),document.writeln("		// Removal conditions"),document.writeln("		if ("),document.writeln("			// Bottom of screen"),document.writeln("			frag.projected.y > centerY + targetHitRadius ||"),document.writeln("			// Sides of screen"),document.writeln("			frag.projected.x < fragLeftBound ||"),document.writeln("			frag.projected.x > fragRightBound ||"),document.writeln("			// Too close to camera"),document.writeln("			frag.z > cameraFadeEndZ"),document.writeln("		) {"),document.writeln("			frags.splice(i, 1);"),document.writeln("			returnFrag(frag);"),document.writeln("			continue;"),document.writeln("		}"),document.writeln("	}"),document.writeln(""),document.writeln("	// 2D sparks"),document.writeln("	for (let i = sparks.length - 1; i >= 0; i--) {"),document.writeln("		const spark = sparks[i];"),document.writeln("		spark.life -= simTime;"),document.writeln("		if (spark.life <= 0) {"),document.writeln("			sparks.splice(i, 1);"),document.writeln("			returnSpark(spark);"),document.writeln("			continue;"),document.writeln("		}"),document.writeln("		spark.x += spark.xD * simSpeed;"),document.writeln("		spark.y += spark.yD * simSpeed;"),document.writeln("		spark.xD *= simAirDragSpark;"),document.writeln("		spark.yD *= simAirDragSpark;"),document.writeln("		spark.yD += gravity * simSpeed;"),document.writeln("	}"),document.writeln(""),document.writeln('	PERF_END("entities");'),document.writeln(""),document.writeln("	// 3D transforms"),document.writeln("	// -------------------"),document.writeln(""),document.writeln('	PERF_START("3D");'),document.writeln(""),document.writeln("	// Aggregate all scene vertices/polys"),document.writeln("	allVertices.length = 0;"),document.writeln("	allPolys.length = 0;"),document.writeln("	allShadowVertices.length = 0;"),document.writeln("	allShadowPolys.length = 0;"),document.writeln("	targets.forEach((entity) => {"),document.writeln("		allVertices.push(...entity.vertices);"),document.writeln("		allPolys.push(...entity.polys);"),document.writeln("		allShadowVertices.push(...entity.shadowVertices);"),document.writeln("		allShadowPolys.push(...entity.shadowPolys);"),document.writeln("	});"),document.writeln(""),document.writeln("	frags.forEach((entity) => {"),document.writeln("		allVertices.push(...entity.vertices);"),document.writeln("		allPolys.push(...entity.polys);"),document.writeln("		allShadowVertices.push(...entity.shadowVertices);"),document.writeln("		allShadowPolys.push(...entity.shadowPolys);"),document.writeln("	});"),document.writeln(""),document.writeln("	// Scene calculations/transformations"),document.writeln('	allPolys.forEach((p) => computePolyNormal(p, "normalWorld"));'),document.writeln("	allPolys.forEach(computePolyDepth);"),document.writeln("	allPolys.sort((a, b) => b.depth - a.depth);"),document.writeln(""),document.writeln("	// Perspective projection"),document.writeln("	allVertices.forEach(projectVertex);"),document.writeln(""),document.writeln('	allPolys.forEach((p) => computePolyNormal(p, "normalCamera"));'),document.writeln(""),document.writeln('	PERF_END("3D");'),document.writeln(""),document.writeln('	PERF_START("shadows");'),document.writeln(""),document.writeln("	// Rotate shadow vertices to light source perspective"),document.writeln("	transformVertices("),document.writeln("		allShadowVertices,"),document.writeln("		allShadowVertices,"),document.writeln("		0,"),document.writeln("		0,"),document.writeln("		0,"),document.writeln("		TAU / 8,"),document.writeln("		0,"),document.writeln("		0,"),document.writeln("		1,"),document.writeln("		1,"),document.writeln("		1"),document.writeln("	);"),document.writeln(""),document.writeln('	allShadowPolys.forEach((p) => computePolyNormal(p, "normalWorld"));'),document.writeln(""),document.writeln("	const shadowDistanceMult = Math.hypot(1, 1);"),document.writeln("	const shadowVerticesLength = allShadowVertices.length;"),document.writeln("	for (let i = 0; i < shadowVerticesLength; i++) {"),document.writeln("		const distance = allVertices[i].z - backboardZ;"),document.writeln("		allShadowVertices[i].z -= shadowDistanceMult * distance;"),document.writeln("	}"),document.writeln("	transformVertices("),document.writeln("		allShadowVertices,"),document.writeln("		allShadowVertices,"),document.writeln("		0,"),document.writeln("		0,"),document.writeln("		0,"),document.writeln("		-TAU / 8,"),document.writeln("		0,"),document.writeln("		0,"),document.writeln("		1,"),document.writeln("		1,"),document.writeln("		1"),document.writeln("	);"),document.writeln("	allShadowVertices.forEach(projectVertex);"),document.writeln(""),document.writeln('	PERF_END("shadows");'),document.writeln(""),document.writeln('	PERF_END("tick");'),document.writeln("}"),document.writeln(""),document.writeln("// draw.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("function draw(ctx, width, height, viewScale) {"),document.writeln('	PERF_START("draw");'),document.writeln(""),document.writeln("	const halfW = width / 2;"),document.writeln("	const halfH = height / 2;"),document.writeln(""),document.writeln("	// 3D Polys"),document.writeln("	// ---------------"),document.writeln('	ctx.lineJoin = "bevel";'),document.writeln(""),document.writeln('	PERF_START("drawShadows");'),document.writeln("	ctx.fillStyle = shadowColor;"),document.writeln("	ctx.strokeStyle = shadowColor;"),document.writeln("	allShadowPolys.forEach((p) => {"),document.writeln("		if (p.wireframe) {"),document.writeln("			ctx.lineWidth = 2;"),document.writeln("			ctx.beginPath();"),document.writeln("			const { vertices } = p;"),document.writeln("			const vCount = vertices.length;"),document.writeln("			const firstV = vertices[0];"),document.writeln("			ctx.moveTo(firstV.x, firstV.y);"),document.writeln("			for (let i = 1; i < vCount; i++) {"),document.writeln("				const v = vertices[i];"),document.writeln("				ctx.lineTo(v.x, v.y);"),document.writeln("			}"),document.writeln("			ctx.closePath();"),document.writeln("			ctx.stroke();"),document.writeln("		} else {"),document.writeln("			ctx.beginPath();"),document.writeln("			const { vertices } = p;"),document.writeln("			const vCount = vertices.length;"),document.writeln("			const firstV = vertices[0];"),document.writeln("			ctx.moveTo(firstV.x, firstV.y);"),document.writeln("			for (let i = 1; i < vCount; i++) {"),document.writeln("				const v = vertices[i];"),document.writeln("				ctx.lineTo(v.x, v.y);"),document.writeln("			}"),document.writeln("			ctx.closePath();"),document.writeln("			ctx.fill();"),document.writeln("		}"),document.writeln("	});"),document.writeln('	PERF_END("drawShadows");'),document.writeln(""),document.writeln('	PERF_START("drawPolys");'),document.writeln(""),document.writeln("	allPolys.forEach((p) => {"),document.writeln("		if (!p.wireframe && p.normalCamera.z < 0) return;"),document.writeln(""),document.writeln("		if (p.strokeWidth !== 0) {"),document.writeln("			ctx.lineWidth = p.normalCamera.z < 0 ? p.strokeWidth * 0.5 : p.strokeWidth;"),document.writeln("			ctx.strokeStyle = p.normalCamera.z < 0 ? p.strokeColorDark : p.strokeColor;"),document.writeln("		}"),document.writeln(""),document.writeln("		const { vertices } = p;"),document.writeln("		const lastV = vertices[vertices.length - 1];"),document.writeln("		const fadeOut = p.middle.z > cameraFadeStartZ;"),document.writeln(""),document.writeln("		if (!p.wireframe) {"),document.writeln("			const normalLight = p.normalWorld.y * 0.5 + p.normalWorld.z * -0.5;"),document.writeln("			const lightness ="),document.writeln("				normalLight > 0 ? 0.1 : ((normalLight ** 32 - normalLight) / 2) * 0.9 + 0.1;"),document.writeln("			ctx.fillStyle = shadeColor(p.color, lightness);"),document.writeln("		}"),document.writeln(""),document.writeln("		// Fade out polys close to camera. `globalAlpha` must be reset later."),document.writeln("		if (fadeOut) {"),document.writeln("			// If polygon gets really close to camera (outside `cameraFadeRange`) the alpha"),document.writeln("			// can go negative, which has the appearance of alpha = 1. So, we'll clamp it at 0."),document.writeln("			ctx.globalAlpha = Math.max("),document.writeln("				0,"),document.writeln("				1 - (p.middle.z - cameraFadeStartZ) / cameraFadeRange"),document.writeln("			);"),document.writeln("		}"),document.writeln(""),document.writeln("		ctx.beginPath();"),document.writeln("		ctx.moveTo(lastV.x, lastV.y);"),document.writeln("		for (let v of vertices) {"),document.writeln("			ctx.lineTo(v.x, v.y);"),document.writeln("		}"),document.writeln(""),document.writeln("		if (!p.wireframe) {"),document.writeln("			ctx.fill();"),document.writeln("		}"),document.writeln("		if (p.strokeWidth !== 0) {"),document.writeln("			ctx.stroke();"),document.writeln("		}"),document.writeln(""),document.writeln("		if (fadeOut) {"),document.writeln("			ctx.globalAlpha = 1;"),document.writeln("		}"),document.writeln("	});"),document.writeln('	PERF_END("drawPolys");'),document.writeln(""),document.writeln('	PERF_START("draw2D");'),document.writeln(""),document.writeln("	// 2D Sparks"),document.writeln("	// ---------------"),document.writeln("	ctx.strokeStyle = sparkColor;"),document.writeln("	ctx.lineWidth = sparkThickness;"),document.writeln("	ctx.beginPath();"),document.writeln("	sparks.forEach((spark) => {"),document.writeln("		ctx.moveTo(spark.x, spark.y);"),document.writeln("		// Shrink sparks to zero length as they die."),document.writeln("		// Speed up shrinking as life approaches 0 (root curve)."),document.writeln("		// Note that sparks already get smaller over time as their speed slows"),document.writeln("		// down from damping. So this is like a double scale down. To counter this"),document.writeln("		// a bit and keep the sparks larger for longer, we'll also increase the scale"),document.writeln("		// a bit after applying the root curve."),document.writeln("		const scale = (spark.life / spark.maxLife) ** 0.5 * 1.5;"),document.writeln("		ctx.lineTo(spark.x - spark.xD * scale, spark.y - spark.yD * scale);"),document.writeln("	});"),document.writeln("	ctx.stroke();"),document.writeln(""),document.writeln("	// Touch Strokes"),document.writeln("	// ---------------"),document.writeln(""),document.writeln("	ctx.strokeStyle = touchTrailColor;"),document.writeln("	const touchPointCount = touchPoints.length;"),document.writeln("	for (let i = 1; i < touchPointCount; i++) {"),document.writeln("		const current = touchPoints[i];"),document.writeln("		const prev = touchPoints[i - 1];"),document.writeln("		if (current.touchBreak || prev.touchBreak) {"),document.writeln("			continue;"),document.writeln("		}"),document.writeln("		const scale = current.life / touchPointLife;"),document.writeln("		ctx.lineWidth = scale * touchTrailThickness;"),document.writeln("		ctx.beginPath();"),document.writeln("		ctx.moveTo(prev.x, prev.y);"),document.writeln("		ctx.lineTo(current.x, current.y);"),document.writeln("		ctx.stroke();"),document.writeln("	}"),document.writeln(""),document.writeln('	PERF_END("draw2D");'),document.writeln(""),document.writeln('	PERF_END("draw");'),document.writeln('	PERF_END("frame");'),document.writeln(""),document.writeln("	// Display performance updates."),document.writeln("	PERF_UPDATE();"),document.writeln("}"),document.writeln(""),document.writeln("// canvas.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("function setupCanvases() {"),document.writeln('	const ctx = canvas.getContext("2d");'),document.writeln("	// devicePixelRatio alias"),document.writeln("	const dpr = window.devicePixelRatio || 1;"),document.writeln("	// View will be scaled so objects appear sized similarly on all screen sizes."),document.writeln("	let viewScale;"),document.writeln("	// Dimensions (taking viewScale into account!)"),document.writeln("	let width, height;"),document.writeln(""),document.writeln("	function handleResize() {"),document.writeln("		const w = window.innerWidth;"),document.writeln("		const h = window.innerHeight;"),document.writeln("		viewScale = h / 1000;"),document.writeln("		width = w / viewScale;"),document.writeln("		height = h / viewScale;"),document.writeln("		canvas.width = w * dpr;"),document.writeln("		canvas.height = h * dpr;"),document.writeln('		canvas.style.width = w + "px";'),document.writeln('		canvas.style.height = h + "px";'),document.writeln("	}"),document.writeln(""),document.writeln("	// Set initial size"),document.writeln("	handleResize();"),document.writeln("	// resize fullscreen canvas"),document.writeln('	window.addEventListener("resize", handleResize);'),document.writeln(""),document.writeln("	// Run game loop"),document.writeln("	let lastTimestamp = 0;"),document.writeln("	function frameHandler(timestamp) {"),document.writeln("		let frameTime = timestamp - lastTimestamp;"),document.writeln("		lastTimestamp = timestamp;"),document.writeln(""),document.writeln("		// always queue another frame"),document.writeln("		raf();"),document.writeln(""),document.writeln("		// If game is paused, we'll still track frameTime (above) but all other"),document.writeln("		// game logic and drawing can be avoided."),document.writeln("		if (isPaused()) return;"),document.writeln(""),document.writeln("		// make sure negative time isn't reported (first frame can be whacky)"),document.writeln("		if (frameTime < 0) {"),document.writeln("			frameTime = 17;"),document.writeln("		}"),document.writeln("		// - cap minimum framerate to 15fps[~68ms] (assuming 60fps[~17ms] as 'normal')"),document.writeln("		else if (frameTime > 68) {"),document.writeln("			frameTime = 68;"),document.writeln("		}"),document.writeln(""),document.writeln("		const halfW = width / 2;"),document.writeln("		const halfH = height / 2;"),document.writeln(""),document.writeln("		// Convert pointer position from screen to scene coords."),document.writeln("		pointerScene.x = pointerScreen.x / viewScale - halfW;"),document.writeln("		pointerScene.y = pointerScreen.y / viewScale - halfH;"),document.writeln(""),document.writeln("		const lag = frameTime / 16.6667;"),document.writeln("		const simTime = gameSpeed * frameTime;"),document.writeln("		const simSpeed = gameSpeed * lag;"),document.writeln("		tick(width, height, simTime, simSpeed, lag);"),document.writeln(""),document.writeln("		// Auto clear canvas"),document.writeln("		ctx.clearRect(0, 0, canvas.width, canvas.height);"),document.writeln("		// Auto scale drawing for high res displays, and incorporate `viewScale`."),document.writeln("		// Also shift canvas so (0, 0) is the middle of the screen."),document.writeln("		// This just works with 3D perspective projection."),document.writeln("		const drawScale = dpr * viewScale;"),document.writeln("		ctx.scale(drawScale, drawScale);"),document.writeln("		ctx.translate(halfW, halfH);"),document.writeln("		draw(ctx, width, height, viewScale);"),document.writeln("		ctx.setTransform(1, 0, 0, 1, 0, 0);"),document.writeln("	}"),document.writeln("	const raf = () => requestAnimationFrame(frameHandler);"),document.writeln("	// Start loop"),document.writeln("	raf();"),document.writeln("}"),document.writeln(""),document.writeln("// interaction.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("// Interaction"),document.writeln("// -----------------------------"),document.writeln(""),document.writeln("function handleCanvasPointerDown(x, y) {"),document.writeln("	if (!pointerIsDown) {"),document.writeln("		pointerIsDown = true;"),document.writeln("		pointerScreen.x = x;"),document.writeln("		pointerScreen.y = y;"),document.writeln("		// On when menus are open, point down/up toggles an interactive mode."),document.writeln("		// We just need to rerender the menu system for it to respond."),document.writeln("		if (isMenuVisible()) renderMenus();"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("function handleCanvasPointerUp() {"),document.writeln("	if (pointerIsDown) {"),document.writeln("		pointerIsDown = false;"),document.writeln("		touchPoints.push({"),document.writeln("			touchBreak: true,"),document.writeln("			life: touchPointLife"),document.writeln("		});"),document.writeln("		// On when menus are open, point down/up toggles an interactive mode."),document.writeln("		// We just need to rerender the menu system for it to respond."),document.writeln("		if (isMenuVisible()) renderMenus();"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("function handleCanvasPointerMove(x, y) {"),document.writeln("	if (pointerIsDown) {"),document.writeln("		pointerScreen.x = x;"),document.writeln("		pointerScreen.y = y;"),document.writeln("	}"),document.writeln("}"),document.writeln(""),document.writeln("// Use pointer events if available, otherwise fallback to touch events (for iOS)."),document.writeln('if ("PointerEvent" in window) {'),document.writeln('	canvas.addEventListener("pointerdown", (event) => {'),document.writeln("		event.isPrimary && handleCanvasPointerDown(event.clientX, event.clientY);"),document.writeln("	});"),document.writeln(""),document.writeln('	canvas.addEventListener("pointerup", (event) => {'),document.writeln("		event.isPrimary && handleCanvasPointerUp();"),document.writeln("	});"),document.writeln(""),document.writeln('	canvas.addEventListener("pointermove", (event) => {'),document.writeln("		event.isPrimary && handleCanvasPointerMove(event.clientX, event.clientY);"),document.writeln("	});"),document.writeln(""),document.writeln("	// We also need to know if the mouse leaves the page. For this game, it's best if that"),document.writeln('	// cancels a swipe, so essentially acts as a "mouseup" event.'),document.writeln('	document.body.addEventListener("mouseleave", handleCanvasPointerUp);'),document.writeln("} else {"),document.writeln("	let activeTouchId = null;"),document.writeln('	canvas.addEventListener("touchstart", (event) => {'),document.writeln("		if (!pointerIsDown) {"),document.writeln("			const touch = event.changedTouches[0];"),document.writeln("			activeTouchId = touch.identifier;"),document.writeln("			handleCanvasPointerDown(touch.clientX, touch.clientY);"),document.writeln("		}"),document.writeln("	});"),document.writeln('	canvas.addEventListener("touchend", (event) => {'),document.writeln("		for (let touch of event.changedTouches) {"),document.writeln("			if (touch.identifier === activeTouchId) {"),document.writeln("				handleCanvasPointerUp();"),document.writeln("				break;"),document.writeln("			}"),document.writeln("		}"),document.writeln("	});"),document.writeln("	canvas.addEventListener("),document.writeln('		"touchmove",'),document.writeln("		(event) => {"),document.writeln("			for (let touch of event.changedTouches) {"),document.writeln("				if (touch.identifier === activeTouchId) {"),document.writeln("					handleCanvasPointerMove(touch.clientX, touch.clientY);"),document.writeln("					event.preventDefault();"),document.writeln("					break;"),document.writeln("				}"),document.writeln("			}"),document.writeln("		},"),document.writeln("		{ passive: false }"),document.writeln("	);"),document.writeln("}"),document.writeln(""),document.writeln("// index.js"),document.writeln("// ============================================================================"),document.writeln("// ============================================================================"),document.writeln(""),document.writeln("setupCanvases();"),document.writeln(""),document.writeln("    </script>"),document.writeln("    <!-- Code injected by live-server -->"),document.writeln("<script>"),document.writeln("	// <![CDATA[  <-- For SVG support"),document.writeln("	if ('WebSocket' in window) {"),document.writeln("		(function () {"),document.writeln("			function refreshCSS() {"),document.writeln('				var sheets = [].slice.call(document.getElementsByTagName("link"));'),document.writeln('				var head = document.getElementsByTagName("head")[0];'),document.writeln("				for (var i = 0; i < sheets.length; ++i) {"),document.writeln("					var elem = sheets[i];"),document.writeln("					var parent = elem.parentElement || head;"),document.writeln("					parent.removeChild(elem);"),document.writeln("					var rel = elem.rel;"),document.writeln('					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {'),document.writeln("						var url = elem.href.replace(/(&|\\?)_cacheOverride=\\d+/, '');"),document.writeln("						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());"),document.writeln("					}"),document.writeln("					parent.appendChild(elem);"),document.writeln("				}"),document.writeln("			}"),document.writeln("			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';"),document.writeln("			var address = protocol + window.location.host + window.location.pathname + '/ws';"),document.writeln("			var socket = new WebSocket(address);"),document.writeln("			socket.onmessage = function (msg) {"),document.writeln("				if (msg.data == 'reload') window.location.reload();"),document.writeln("				else if (msg.data == 'refreshcss') refreshCSS();"),document.writeln("			};"),document.writeln("			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {"),document.writeln("				console.log('Live reload enabled.');"),document.writeln("				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);"),document.writeln("			}"),document.writeln("		})();"),document.writeln("	}"),document.writeln("	else {"),document.writeln("		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');"),document.writeln("	}"),document.writeln("	// ]]>"),document.writeln("</script>"),document.writeln("</body>"),document.writeln("</html>");

